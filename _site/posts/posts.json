[
  {
    "path": "posts/2022-08-29-dinamica-da-volatilidade-implicita/",
    "title": "Din√¢mica da Volatilidade Impl√≠cita",
    "description": "Como a volatilidade impl√≠cita das op√ß√µes evolui no tempo? H√° diversas formas de se avaliar isso.\nAqui veremos como √© a din√¢mica na volatilidade das op√ß√µes ATM no tempo.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-08-29",
    "categories": [],
    "contents": "\r\nH√° divesos estudos sobre o comportamento das op√ß√µes e sobre quais fatores s√£o mais importantes para explicar as suas mudan√ßas de pre√ßos. Sabemos que, depois do ativo objeto, a volatilidade impl√≠cita √© a vari√°vel que mais influiencia nas varia√ß√µes de pre√ßos das op√ß√µes. Dessa forma, √© importante entender como se d√£o as suas varia√ß√µes, de outra forma, √© importante conhecer a sua din√¢mica.\r\nAqui vou carregar o hist√≥rico de op√ß√µes de PETR4 desde o come√ßo de 2022, calcular a volatilidade impl√≠cita e o delta para cada uma das op√ß√µes, e para cada data de refer√™ncia, selecionar as op√ß√µes, call e put, mais pr√≥ximas da data de vencimento e com o delta mais pr√≥ximo de 50%.\r\nAssim teremos uma op√ß√£o, para cada tipo, call e put, em cada data de refer√™ncia. Dessa maneira, √© poss√≠vel construir uma s√©rie temporal de volatilidade impl√≠cita por tipo de op√ß√£o.\r\nAs op√ß√µes mais pr√≥ximas do vencimento (ou primeiro vencimento), apresentam a maior liquidez dentre as op√ß√µes negociadas. Aqui estamos selecionando o primeiro vencimento at√© a sua expira√ß√£o, entretanto, √© interessante que seja realizada uma an√°lise da liquidez das op√ß√µes a medida que se aproximam do vencimento para que uma estrat√©gia de rolagem seja definida. Pois, na medida que o primeiro vencimento se aproxima, a liquidez migra para o segundo vencimento. O desafio √© identificar a din√¢mica dessa migra√ß√£o. Aqui isso n√£o ser√° levado em considera√ß√£o, vamos carregar as op√ß√µes do primeiro vencimento at√© a sua expira√ß√£o.\r\nCome√ßando com o carregamento de pacotes.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(oplib)\r\nlibrary(bizdays)\r\nlibrary(tidyverse)\r\n\r\n\r\nAs op√ß√µes s√£o carregadas via o arquivo COTAHIST (rb3::cotahist_get) e as curvas de juro s√£o baixadas do site da B3 na p√°gina de Taxas de Refer√™ncia (rb3::yc_mget).\r\n\r\n\r\nrefdate <- getdate(\"last bizday\", Sys.Date(), \"Brazil/B3\")\r\nch <- cotahist_get(refdate, \"yearly\")\r\nyc <- yc_mget(first_date = as.Date(\"2022-01-01\"), last_date = refdate)\r\n\r\n\r\nVamos utilizar a fun√ß√£o rb3::cotahist_options_by_symbol_superset para obter o super dataset para op√ß√µes de PETR4. De posse do super dataset, os dados de vencimento e taxas de juros s√£o formatados para o c√°lculo da volatilidade impl√≠cita e do delta para todas as op√ß√µes.\r\n\r\n\r\nsymbol <- \"PETR4\"\r\n\r\nop <- cotahist_options_by_symbol_superset(symbol, ch, yc)\r\n\r\nop_vol <- op |>\r\n  mutate(\r\n    biz_days = bizdays(\r\n      refdate, following(maturity_date, \"Brazil/B3\"), \"Brazil/B3\"\r\n    ),\r\n    time_to_maturity = biz_days / 252,\r\n    rate = log(1 + r_252),\r\n    bsm_impvol = bsmimpvol(\r\n      close, type, close.underlying, strike, time_to_maturity, rate, 0\r\n    ),\r\n    delta = bsmdelta(\r\n      type, close.underlying, strike, time_to_maturity, rate, 0, bsm_impvol\r\n    )\r\n  ) |>\r\n  select(\r\n    refdate, symbol, volume, maturity_date,\r\n    type, close.underlying, strike, time_to_maturity, rate,\r\n    biz_days, close, high, low, bsm_impvol, delta\r\n  )\r\n\r\n\r\nDin√¢mica da Volatilidade ATM\r\nComo todos os c√°lculos realizados vamos selecionar as op√ß√µes ATM do primeiro vencimento para cada data de refer√™ncia. Fazemos uma segmenta√ß√£o dos dados por refdate e para cada chunk selecionamos o primeiro vencimento.\r\n\r\n\r\nop1 <- op_vol |>\r\n  split(op_vol$refdate) |>\r\n  map_dfr(function(df) {\r\n    first_mat <- df$maturity_date[which.min(df$maturity_date)]\r\n    filter(df, maturity_date == first_mat)\r\n  })\r\n\r\n\r\nO dataframe op1 tem op√ß√µes call e put, em diversos strikes, para cada data de refer√™ncia. Agora precisamos selecionar as op√ß√µes mais pr√≥ximas do dinheiro, ou seja, as op√ß√µes com delta mais pr√≥ximo de 50%. Como h√° uma diferen√ßa de sinal entre op√ß√µes call e put, vamos calcular as diferen√ßas em valores absolutos do delta em rela√ß√£o ao valor 0.5 (delta = 50%).\r\n\r\n\r\nop1_atm <- split(op1, op1$refdate) |>\r\n  map_dfr(function(df) {\r\n    df_type <- filter(df, type == \"Put\")\r\n    df1 <- df_type[which.min(abs(abs(df_type$delta) - 0.5)), ]\r\n\r\n    df_type <- filter(df, type == \"Call\")\r\n    df2 <- df_type[which.min(abs(abs(df_type$delta) - 0.5)), ]\r\n\r\n    bind_rows(df1, df2)\r\n  })\r\n\r\n\r\nO dataframe op1_atm tem, para cada data de refer√™ncia, 1 call ATM e 1 put ATM.\r\nVamos visualizar a s√©rie temporal de volatilidades impl√≠citas para estas op√ß√µes.\r\n\r\n\r\nop1_atm |>\r\n  ggplot(aes(x = refdate, y = bsm_impvol, colour = type)) +\r\n  geom_line() +\r\n  geom_point() +\r\n  facet_wrap(type ~ .) +\r\n  labs(\r\n    x = \"Data\", y = \"Volatilidade Impl√≠cita\",\r\n    title = \"S√©rie Hist√≥rica Volatilidade Impl√≠cita (ATM) - PETR4\",\r\n    subtitle = \"Volatilidade impl√≠cita de op√ß√µes com delta mais pr√≥ximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\n√â poss√≠vel notar que a din√¢mica da volatilidade, entre as op√ß√µes call e put, √© bem comportada. H√° eventuais momentos de diverg√™ncia, contudo, o comportamento das duas s√©ries √© bastante semelhante. As s√©ries apresentam um forte comportamento de revers√£o √† m√©dia, o que √© caracter√≠stico desse tipo de vari√°vel.\r\nOutro ponto interessante √© verificar quais os pre√ßos de exerc√≠cio para as op√ß√µes ATM selecionadas. Pois, uma vez que o pre√ßo do ativo objeto muda, o delta da op√ß√£o muda e o pre√ßo de exerc√≠cio que representa o delta tamb√©m muda.\r\n\r\n\r\nop1_atm |>\r\n  ggplot(aes(x = refdate, y = strike, colour = type)) +\r\n  geom_line() +\r\n  geom_point(aes(shape = type), size = 3) +\r\n  labs(\r\n    x = \"Data\", y = \"Strike\",\r\n    title = \"S√©rie Hist√≥rica Strikes (ATM) - PETR4\",\r\n    subtitle = \"Pre√ßos de exerc√≠cio de op√ß√µes com delta mais pr√≥ximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"top\", legend.title = element_blank())\r\n\r\n\r\n\r\nAqui as s√©ries s√£o praticamente as mesmas, indicando que as op√ß√µes ATM, calls e puts, possuem os mesmos strikes. Em poucos pontos h√° uma diferen√ßa nos pre√ßos de exerc√≠cio. √â interessante que este ponto seja melhor avaliado e talvez a liquidez das op√ß√µes ajude a explicar estas diferen√ßas.\r\nVamos observar os deltas das op√ß√µes ATM selecionadas. Uma vez que estamos selecionando op√ß√µes ATM, √© interessante que os deltas estejam pr√≥ximos de 50%. Mas como se d√° essa sele√ß√£o? No gr√°fico abaixo vemos que os deltas de calls e puts oscilam em torno de 50% e est√£o sempre pr√≥ximos entre si, h√° poqu√≠ssimos casos em que o delta da call est√° acima de 50% e o delta da put est√° abaixo de 50%. Novamente, cabe uma melhor investiga√ß√£o para melhor compreender os fatores causadores da diverg√™ncia.\r\n\r\n\r\nop1_atm |>\r\n  mutate(delta = ifelse(delta < 0, 1 + delta, delta)) |>\r\n  ggplot(aes(x = refdate, y = delta, colour = type)) +\r\n  geom_line() +\r\n  geom_point() +\r\n  labs(\r\n    x = \"Data\", y = \"Delta\",\r\n    title = \"S√©rie Hist√≥rica Deltas (ATM) - PETR4\",\r\n    subtitle = \"Delta de op√ß√µes com delta mais pr√≥ximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"top\", legend.title = element_blank())\r\n\r\n\r\n\r\nUma vez que constru√≠mos as s√©ries temporais para a volatilidade de op√ß√µes ATM, o pr√≥ximo passo √© modelar essa s√©rie. Um problema interessante √© comparar essa din√¢mica com a volatilidade realizada, talvez separando por cada vencimento. Idealmente a volatilidade impl√≠cita deveria convergir para a volatilidade realizada. Outro ponto que ficou em aberto e a avalia√ß√£o da liquidez e sua consequ√™ncia na estrat√©gia de rolagem. Aqui estamos selecionando as op√ß√µes mais pr√≥ximas do ATM para obter as volatilidades. Uma alternativa √© fazer o ajuste de um modelo e obter a volatilidade te√≥rica par um delta de 50%. Em geral, como a liquidez se concentra pr√≥ximo √† vizinhan√ßa das op√ß√µes no dinheiro, h√° bastante informa√ß√£o nessa regi√£o para obter um bom modelo ajustado.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-29-dinamica-da-volatilidade-implicita/dinamica-da-volatilidade-implicita_files/figure-html5/op1-vol-atm-1.png",
    "last_modified": "2022-08-29T09:16:09-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-08-17-movimento-da-parte-longa-da-curva-de-juros/",
    "title": "Movimento da Parte Longa da Curva de Juros",
    "description": "A reuni√£o do COPOM no come√ßo do m√™s de agosto de 2022 trouxe um tom que\ninfluenciou a din√¢mica da parte longa da curva de juros.\nAqui apresento uma anima√ß√£o do movimento da curva de juros nas duas primeiras semanas de agosto\nde 2022.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-08-17",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nA reuni√£o do COPOM de 3 de agosto trouxe uma mudan√ßa na estrutura da curva de juros, tanto para a parte curta como para a parte longa. A interpreta√ß√£o do comunicado por agentes de mercado √© de o ciclo de alta de juros est√° pr√≥ximo do fim.\r\nNa pr√°tica a din√¢mica da parte longa da curva de juros foi bastante afetada. Aqui apresento uma anima√ß√£o onde observa-se o movimento da curva de juros nas duas primeiras semanas do m√™s de agosto de 2022. A reuni√£o do COPOM aconteceu em 3 de agosto. Fica claro pela anima√ß√£o a mudan√ßa nas expectativas de longo prazo para a curva.\r\nVamos utilizar o üì¶ {rb3} para obter as curvas e o üì¶ {fixedincome} na constru√ß√£o dos gr√°ficos da estrutura a termo de juros. A anima√ß√£o √© construida com o üì¶ {animation}.\r\n\r\n\r\nlibrary(fixedincome)\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\n\r\nget_di1_curve <- function(refdate) {\r\n  fut <- futures_get(refdate)\r\n  yc <- yc_get(refdate)\r\n  df <- yc_superset(yc, fut)\r\n\r\n  df_curve <- bind_rows(\r\n    df |> slice(1) |> select(biz_days, r_252),\r\n    df |> filter(!is.na(symbol)) |> select(biz_days, r_252)\r\n  ) |>\r\n    filter(!duplicated(biz_days))\r\n\r\n  spotratecurve(\r\n    df_curve$r_252, df_curve$biz_days, \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n    refdate = refdate\r\n  )\r\n}\r\n\r\n\r\nVamos obter as curvas para os dias √∫teis entre 2022-08-01 e 2022-08-16 e coloc√°-las em uma lista. Na sequ√™ncia a anima√ß√£o ser√° constru√≠da com cada uma das curvas da lista, sendo que a primeira curva tem a cor vermelha e a √∫ltima tem cor azul, as demais curvas s√£o em cinza. O objetivo √© acompanhar a evolu√ß√£o das curvas tendo em destaque o come√ßo e fim.\r\n\r\n\r\ndates <- bizseq(\"2022-08-01\", \"2022-08-16\", \"Brazil/ANBIMA\")\r\ncurves <- lapply(seq_along(dates), function(ix) get_di1_curve(dates[ix]))\r\n\r\nanim <- animation::saveGIF(\r\n  {\r\n    g <- autoplot(curves[[1]], curve.x.axis = \"terms\", colour = \"red\") +\r\n      autolayer(curves[[1]], curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"red\") +\r\n      ylim(0.11, 0.14) +\r\n      theme_bw() +\r\n      theme(legend.position = \"none\") +\r\n      labs(\r\n        x = \"Prazos\", y = NULL, title = \"Curvas de Juros Prefixados DI1\",\r\n        subtitle = \"Entre as datas 2022-08-01 e 2022-08-16\",\r\n        caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n      )\r\n    print(g)\r\n\r\n    for(curve in curves[-c(1, length(curves))]) {\r\n      g <- g + autolayer(curve, curve.x.axis = \"terms\", colour = \"grey\") +\r\n        autolayer(curve,\r\n          curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"grey\"\r\n        )\r\n      print(g)\r\n    }\r\n\r\n    g <- g + autolayer(curves[[length(curves)]], curve.x.axis = \"terms\", colour = \"blue\") +\r\n      autolayer(curves[[length(curves)]],\r\n        curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"blue\"\r\n      )\r\n    print(g)\r\n  },\r\n  interval = 0.8,\r\n  ani.height = 400,\r\n  ani.width = 704\r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-17-movimento-da-parte-longa-da-curva-de-juros/animation.gif",
    "last_modified": "2022-08-17T07:25:40-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-06-24-super-datasets-para-opcoes-de-acoes/",
    "title": "Super Datasets para Op√ß√µes de A√ß√µes",
    "description": "Um dos super datasets do pacote {rb3} √© o de op√ß√µes de a√ß√µes.\nCom este dataset √© poss√≠vel realizar diversos c√°lculos com dados de op√ß√µes de a√ß√µes, como\ncalcular a volatilidade impl√≠cita das op√ß√µes, as gregas e at√© mesmo fazer o ajuste de\nmodelos te√≥ricos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-24",
    "categories": [],
    "contents": "\r\nDados de op√ß√µes de a√ß√µes finalmente dispon√≠veis de forma simples e direta. Durante muito tempo busquei isso, os dados de op√ß√µes s√£o mais chatos pois precisam de outros dados para a realiza√ß√£o dos c√°lculos. Ter apenas os dados de pr√™mio das op√ß√µes (pre√ßos das op√ß√µes) n√£o permite que diversas das medidas de interesse associadas a op√ß√µes, como as gregas e a volatilidade impl√≠cita, sejam calculadas. Utilizando Black & Scholes √© necess√°rio ainda ter o pre√ßo do ativo objeto (pre√ßo da a√ß√£o) e as taxas de juros. Com estas informa√ß√µes √© poss√≠vel calcular a volatilidade e a partir da√≠ todas as demais medidas de interesse podem ser calculadas.\r\nVou mostrar aqui como calcular a volatilidade e as gregas para op√ß√µes a partir de dados obtidos com o pacote {rb3}. Para realizar os c√°lculos com as op√ß√µes eu utilizo o pacote {oplib} que desenvolvi com diversos modelos implementados:\r\nBlack, Scholes & Merto para apre√ßamento das op√ß√µes\r\nBlack para apre√ßamento de op√ß√µes sobre futuros, utilizado em op√ß√µes sobre √≠ndices de taxas de juros, como IDI\r\nCorrado-Su para o apre√ßamento de op√ß√µes considerando assimetria e curtose\r\nentre outros\r\nEste pacote ainda √© experimental, n√£o est√° publicado no CRAN e a documenta√ß√£o ainda est√° em desenvolvimento.\r\nVamos come√ßar carregando os pacotes\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(tidyverse)\r\nlibrary(oplib)\r\n\r\n\r\nVamos selecionar o √∫ltimo dia √∫til para obter os dados di√°rios do arquivo COTAHIST disponibilizado pela B3. O arquivo COTAHIST traz diversas informa√ß√µes do mercado de a√ß√µes e inclui as op√ß√µes. Adicionalmente, precisamos das taxas de juros e utilizo a fun√ß√£o rb3::yc_get para obter a curva de juros para a data de refer√™ncia.\r\n\r\n\r\nrefdate <- preceding(\"2022-06-24\", \"Brazil/ANBIMA\")\r\nch <- cotahist_get(refdate, \"daily\")\r\nyc <- yc_get(refdate)\r\n\r\n\r\nCom os dados de a√ß√µes e op√ß√µes, pelo arquivo COTAHIST, e com as taxas de juros, utilizo a fun√ß√£o rb3::cotahist_options_by_symbol_superset para obter os dados de op√ß√µes para um s√≠mbolo espec√≠fico. Aqui vou utilizar PETR4 que √© uma das a√ß√µes com maior volume de negocia√ß√£o na bolsa.\r\n\r\n\r\nsymbol_ <- \"PETR4\"\r\nop1 <- cotahist_options_by_symbol_superset(symbol_, ch, yc)\r\n\r\n\r\nNo data.frame op1 temos informa√ß√µes de pre√ßo da a√ß√£o na data de refer√™ncia, pre√ßos das op√ß√µes, taxas de juros, vencimento das op√ß√µes, volumes de negocia√ß√£o e diversas outras informa√ß√µes.\r\n\r\n\r\nop1\r\n\r\n# A tibble: 437 x 28\r\n   refdate    symbol   type  strike maturity~1  open  high   low close\r\n   <date>     <chr>    <fct>  <dbl> <date>     <dbl> <dbl> <dbl> <dbl>\r\n 1 2022-06-24 PETRA140 Call    1.94 2023-01-20 24.8  24.8  24.8  24.8 \r\n 2 2022-06-24 PETRA239 Call   50.4  2023-01-20  0.09  0.24  0.09  0.23\r\n 3 2022-06-24 PETRA281 Call   18.4  2023-01-20  9.6   9.6   9.6   9.6 \r\n 4 2022-06-24 PETRA297 Call   30.2  2023-01-20  2.7   2.7   2.7   2.7 \r\n 5 2022-06-24 PETRA359 Call   29.4  2023-01-20  2.87  2.87  2.87  2.87\r\n 6 2022-06-24 PETRA361 Call   26.4  2023-01-20  4.3   4.3   4.23  4.23\r\n 7 2022-06-24 PETRD450 Call   38.4  2023-04-20  1.42  1.42  1.42  1.42\r\n 8 2022-06-24 PETRG1   Call   13.4  2022-07-15 13.7  13.7  12.6  12.6 \r\n 9 2022-06-24 PETRG121 Call   19.2  2022-07-15  7.87  7.87  7.36  7.37\r\n10 2022-06-24 PETRG178 Call   20.2  2022-07-15  6.7   6.7   6.45  6.45\r\n# ... with 427 more rows, 19 more variables: average <dbl>,\r\n#   volume <dbl>, traded_contracts <dbl>,\r\n#   transactions_quantity <int>, distribution_id <int>,\r\n#   symbol.underlying <chr>, open.underlying <dbl>,\r\n#   high.underlying <dbl>, low.underlying <dbl>,\r\n#   close.underlying <dbl>, average.underlying <dbl>, best_bid <dbl>,\r\n#   best_ask <dbl>, volume.underlying <dbl>, ...\r\n\r\npara simplificar os c√°lculos vou separar duas informa√ß√µes √∫teis, os vencimentos das op√ß√µes e o pre√ßo de fechamento da a√ß√£o, que √© √∫nico para a data de refer√™ncia. Os vencimentos das op√ß√µes s√£o ordenados para que eu possa facilmente selecionar um vencimento desejado.\r\n\r\n\r\nmaturities <- unique(op1$maturity_date) |> sort()\r\nclose_underlying <- op1$close.underlying[1]\r\n\r\n\r\nAs op√ß√µes de a√ß√µes, tipicamente, possuem maior liquidez no primeiro vencimento dispon√≠vel. Por isso, vou selecionar todas as op√ß√µes com maturity_date == maturities[1].\r\n\r\n\r\nop_vol <- op1 |>\r\n  filter(maturity_date == maturities[1]) |>\r\n  mutate(\r\n    biz_days = bizdays(\r\n      refdate, following(maturity_date, \"Brazil/ANBIMA\"), \"Brazil/ANBIMA\"\r\n    ),\r\n    time_to_maturity = biz_days / 252,\r\n    rate = log(1 + r_252),\r\n    impvol = bsmimpvol(\r\n      close, type, close.underlying, strike, time_to_maturity, rate, 0\r\n    ),\r\n    delta = bsmdelta(\r\n      type, close.underlying, strike, time_to_maturity, rate, 0, impvol\r\n    )\r\n  ) |>\r\n  select(\r\n    symbol, volume,\r\n    type, close.underlying, strike, time_to_maturity, rate, impvol,\r\n    delta, biz_days, volume\r\n  )\r\n\r\n\r\nAp√≥s a sele√ß√£o das op√ß√µes, uma s√©rie de c√°lculos s√£o realizados para obter:\r\ndias √∫teis at√© o vencimento biz_days\r\nprazo em anos at√© o vencimento time_to_maturity\r\ntaxas de juros em capitaliza√ß√£o cont√≠nua rate\r\nvolatilidade impl√≠cita impvol com o modelo Black & Scholes\r\na grega delta para o modelo Black & Scholes\r\nEm seguida algumas vari√°veis s√£o selecionadas para a visualiz√ß√£o dos dados.\r\nVamos visualizar o smile de volatilidade para com os pre√ßos de exerc√≠cio das op√ß√µes no eixo X Coloco uma linha vertical marcando o n√≠vel do pre√ßo do ativo objeto, facilitando a interpreta√ß√£o do que est√° dentro/fora do dinheiro para as op√ß√µes de compra e venda (Calls e Puts). O tamanho de cada ponto √© definido pelo volumen de negocia√ß√£o de cada op√ß√£o. Interessante notar que os maiores volumes ficam nos strikes pr√≥ximos do pre√ßo atual do ativo objeto. Estas s√£o as op√ß√µes ATM, no dinheiro.\r\n\r\n\r\nop_vol |>\r\n  filter(!is.na(impvol)) |>\r\n  ggplot(aes(x = strike, y = impvol, colour = type, size = volume)) +\r\n  geom_point() +\r\n  geom_vline(xintercept = close_underlying, alpha = 0.5, size = 1) +\r\n  facet_wrap(type ~ biz_days) +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = \"Strike\", y = \"Implied Volatility\",\r\n    title = str_glue(\"Equity Options Volatility - {symbol_} {format(refdate)}\")\r\n  )\r\n\r\n\r\n\r\nAbaixo temos o smile de volatilidade com o delta das op√ß√µes no eixo X. Aqui fica mais f√°cil visualizar as op√ß√µes ATM, pois estas tem delta de 0.5 (ou -0.5 no caso das Puts).\r\n\r\n\r\nop_vol |>\r\n  filter(!is.na(impvol)) |>\r\n  ggplot(aes(x = delta, y = impvol, colour = type, size = volume)) +\r\n  geom_point() +\r\n  geom_vline(xintercept = c(-0.5, 0.5), alpha = 0.5, size = 1) +\r\n  facet_wrap(~ biz_days, scales = \"free\") +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = \"Delta\", y = \"Implied Volatility\",\r\n    title = str_glue(\"Equity Options Volatility - {symbol_} {format(refdate)}\")\r\n  )\r\n\r\n\r\n\r\nO objetivo deste post √© mostrar como √© f√°cil obter dados de op√ß√µes com o pacote {rb3} e com o pacote {oplib} realizar os c√°lculos com estes dados.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-24-super-datasets-para-opcoes-de-acoes/super-datasets-para-opcoes-de-acoes_files/figure-html5/strike-vol-1.png",
    "last_modified": "2022-08-22T07:18:37-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-19-super-datasets-do-pacote-rb3/",
    "title": "Super Datasets do Pacote rb3",
    "description": "O pacote {rb3} traz fun√ß√µes que retornam *super datasets*, conjuntos de dados mais ricos juntando\na informa√ß√£o de diferentes datasets obtidos com as fun√ß√µes do pacote.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-19",
    "categories": [],
    "contents": "\r\nA vers√£o 0.0.3 do pacote {rb3} trouxe fun√ß√µes que retornam super datasets. Estes super datasets s√£o dataframes com dados organizados para um fim espec√≠fico. Por exemplo, a fun√ß√£o rb3::yc_get retorna um dataframe com dados da curva de juros para diversos v√©rtices, dentre os v√©rtices retornados alguns s√£o referentes aos vencimentos dos contratos futuros utilizados para produzir a curva original. Para alguns problemas √© interessante conhecer quais v√©rtices s√£o referentes aos futuros, por exemplo, na cria√ß√£o de fatores primitivos de risco, onde a interpola√ß√£o deve ser realizada utilizando apenas os futuros. Os contratos futuros podem ser obtidos com a fun√ß√£o rb3::futures_get. Dessa maneira, a fun√ß√£o rb3::yc_superset junta os dados retornados pelas fun√ß√µes rb3::yc_get e rb3::futures_get identificando os vencimentos dos contratos futuros na curva de juros. Por isso super dataset, √© um dataset mais rico!\r\nAtualmente o pacote apresenta as seguintes fun√ß√µes superset:\r\nrb3::yc_superset retorna a curva de juros de prefixados com os contratos fututos DI1 identificados.\r\nrb3::yc_usd_superset retorna a curva de cupom cambial com os contratos fututos DOL identificados.\r\nrb3::yc_ipca_superset retorna a curva de juros reais com os contratos fututos DAP identificados.\r\nrb3::cotahist_equity_options_superset retorna dados de op√ß√µes de a√ß√µes com informa√ß√µes de a√ß√µes e taxas de juros.\r\nVou exemplificar a utiliza√ß√£o de um super dataset com a fun√ß√£o rb3::yc_superset. Vou criar uma curva de juros apenas com os contratos futuros de DI1. Mas antes vou responder uma pergunta que talvez tenha chegado a cabe√ßa dos leitores: Por que criar uma curva de juros apenas com os contratos futuros se j√° tenho uma curva de juros cheia de v√©rtices? Primeiramente, toda curva de juros nasce a partir de um conjunto de contratos, no caso da curva prefixada utiliza-se os contratos futuros DI1, mais a taxa DI no v√©rtice de 1 dia √∫til, assim, estaria retornando a curva ao seu estado original. Logo, todos os demais v√©rtices da curva s√£o obtidos a partir da interpola√ß√£o entre os contratos futuros. Adicionalmente, caso eu precise de um v√©rtice que n√£o est√° na curva ser√° necess√°rio interpolar e como interpolar se n√£o conhe√ßo os v√©rtices referentes aos futuros? Bem, posso interpolar nos v√©rtices presentes, mas assim estaria interpolando sobre v√©rtices interpolados. N√£o √© um grande problema fazer isso, mas isso pode trazer problemas na contru√ß√£o de fatores de risco para taxa de juros, por exemplo.\r\nDando sequ√™ncia, primeiro utilizamos o {rb3} para obter os dados dos futuros e da curva para a data de refer√™ncia.\r\n\r\n\r\nlibrary(rb3)\r\n\r\nrefdate <- \"2022-06-17\"\r\n\r\nfut <- futures_get(refdate)\r\nyc <- yc_get(refdate)\r\n\r\n\r\nDepois passo estes dados para a fun√ß√£o yc_superset que junta os dados para indentificar os contratos futuros.\r\n\r\n\r\ndf <- yc_superset(yc, fut)\r\ndf |> head()\r\n\r\n# A tibble: 6 x 7\r\n  refdate    cur_days biz_days forward_date r_252 r_360 symbol\r\n  <date>        <int>    <dbl> <date>       <dbl> <dbl> <chr> \r\n1 2022-06-17        3        1 2022-06-20   0.132 0     <NA>  \r\n2 2022-06-17        7        5 2022-06-24   0.132 0.134 <NA>  \r\n3 2022-06-17       12        8 2022-06-29   0.132 0.125 <NA>  \r\n4 2022-06-17       13        9 2022-06-30   0.132 0.13  <NA>  \r\n5 2022-06-17       14       10 2022-07-01   0.132 0.134 DI1N22\r\n6 2022-06-17       21       15 2022-07-08   0.132 0.134 <NA>  \r\n\r\nTendo o super dataset eu filtro as linhas referentes aos futuros e a linha referente a 1 dia √∫til.\r\n\r\n\r\nlibrary(dplyr)\r\n\r\ndf_curve <- bind_rows(\r\n  df |> filter(biz_days == 1) |> select(biz_days, r_252),\r\n  df |> filter(!is.na(symbol)) |> select(biz_days, r_252)\r\n)\r\n\r\ndf_curve |> head()\r\n\r\n# A tibble: 6 x 2\r\n  biz_days r_252\r\n     <dbl> <dbl>\r\n1        1 0.132\r\n2       10 0.132\r\n3       31 0.132\r\n4       54 0.133\r\n5       75 0.134\r\n6       95 0.134\r\n\r\nPronto! Tenho a curva original novamente.\r\nApenas para ilustrar, vamos utilizar o pacote {fixedincome} para construir um objeto de curva de juros e visualizar os dados.\r\n\r\n\r\nlibrary(fixedincome)\r\n\r\ncurve <- spotratecurve(\r\n  df_curve$r_252, df_curve$biz_days, \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n  refdate = as.Date(refdate)\r\n)\r\n\r\n\r\nVisualizando a curva.\r\n\r\n\r\nggspotratecurveplot(curve)\r\n\r\n\r\n\r\nVisualizando para um horizonte mais curto e adicionando as taxas a termo.\r\n\r\n\r\ncurve_2y <- curve |> fixedincome::first(\"2 years\")\r\nggspotratecurveplot(curve_2y) +\r\n  ggplot2::autolayer(forwardrate(curve_2y))\r\n\r\n\r\n\r\nBem, os super datasets est√£o a√≠ para ajudar! Entregam dados da B3 mais mastigados para as necessidades dos quants do mercado brasileiro.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-19-super-datasets-do-pacote-rb3/super-datasets-do-pacote-rb3_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2022-08-18T07:50:26-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-18-16-anos-de-curva-prefixada/",
    "title": "16 anos de Curva Prefixada",
    "description": "Observando a din√¢mica da estrutura a termo de juros no Brasil e nos Estados\nUnidos ao longo dos √∫ltimos 16 anos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-18",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(dplyr)\r\nlibrary(fixedincome)\r\nlibrary(ggplot2)\r\n\r\n\r\n\r\n\r\n\r\n\r\nO pacote {rb3} faz extra√ß√µes de dados do site da B3. Temos diversas informa√ß√µes dispon√≠veis no site inclusive o hist√≥rico de diversos dados.\r\nUm conjunto de dados que mais utilizo s√£o os pre√ßos de ajuste dos contratos futuros. Este hist√≥rico √© um dos mais antigos dispon√≠vel.\r\nVou baixar todo o hist√≥rico de contratos futuros desde 2007. A partir dos pre√ßos de ajuste √© poss√≠vel construir o hist√≥rico de curvas prefixadas. Depois vou fazer uma segmenta√ß√£o pelo ano da data de refer√™ncia para que seja poss√≠vel visualizar, para cada ano, todo o espectro de curvas no ano.\r\nVou come√ßar baixando todos os dados desde 2007 at√© a √∫ltima data dispon√≠vel. Para isso vou utilizar a fun√ß√£o rb3::futures_mget. Isso leva um bom tempo!\r\n\r\n\r\ndf <- futures_mget(\r\n  first_date = \"2007-01-01\",\r\n  last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\")\r\n)\r\n\r\n\r\n\r\n√â necess√°rio filtrar os contratos futuros de DI1 para construir a curva prefixada.\r\n\r\n\r\ndf_di1 <- df |> filter(commodity == \"DI1\")\r\n\r\n\r\n\r\nPara construir a curva prefixada √© necess√°rio obter as datas de vencimento dos contratos futuros. Para isso utilizo a fun√ß√£o rb3::maturity2date que converte o c√≥digo de vencimento em data. Adicionalmente fa√ßo o ajuste da data de refer√™ncia criando a coluna fixing, calculo os dias √∫teis (coluna business_days) e a taxa de juros com base no pre√ßo de ajuste price gerando a coluna adjusted_tax.\r\n\r\n\r\ndf_di1_futures <- df_di1 |>\r\n  mutate(\r\n    maturity_date = maturity2date(maturity_code),\r\n    fixing = following(maturity_date, \"Brazil/ANBIMA\"),\r\n    business_days = bizdays(refdate, fixing, \"Brazil/ANBIMA\"),\r\n    adjusted_tax = implied_rate(\"discrete\", business_days / 252, 100000 / price)\r\n  ) |>\r\n  filter(business_days > 0)\r\n\r\n\r\n\r\nTermino filtrando as linhas com business_days maior que zero, pois n√£o me interessam os futuros na data de vencimento.\r\nAgora vamos gerar a visualiza√ß√£o com ggplot2.\r\n\r\n\r\ndf_di1_futures |>\r\n  mutate(year = as.integer(format(refdate, \"%Y\"))) |>\r\n  ggplot(aes(\r\n    x = business_days, y = adjusted_tax,\r\n    group = refdate\r\n  )) +\r\n  geom_line(alpha = 0.2) +\r\n  facet_wrap(. ~ year) +\r\n  labs(\r\n    x = \"Dias √öteis\", y = \"Taxas\",\r\n    title = \"16 anos de Curva Prefixada\",\r\n    subtitle = \"Curvas constru√≠das a partir dos pre√ßos de ajuste dos contratos Futuros DI1\",\r\n    caption = \"Fonte: B3 (obtidos com \\U1F4E6 rb3) - wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nCurioso ver a mudan√ßa de shape da curva entre os anos e ao longo de cada ano. Uma coisa curiosa √© observar os anos de 2016, 2017 e 2018. 2016/2017 foram os anos do impechemant da presidente Dilma. Em 2016 a parte curta da curva variou pouco e a parte longa variou muito. Em 2017 aconteceu o oposto, a parte curta da curva variou mais que a parte longa da curva. Nestes anos, as mudan√ßas afetam diretamente o shape da curva. Em 2018, o ano da elei√ß√£o e da facada do Bolsonaro, h√° uma grande varia√ß√£o na parte longa da curva, mas sem alterar o shape da curva. Ainda √© poss√≠vel avaliar o comportamento da curva com os demais eventos pol√≠ticos e econ√¥micos. Em 2021, por exemplo, onde ocorreu uma eleva√ß√£o da taxa SELIC e uma piora do cen√°rio fiscal, temos um espectro muita amplo do shape da curva.\r\n√â poss√≠vel construir uma visualiza√ß√£o equivalente utilizando dados da curva americana que podem ser obtidos com o pacote Quandl.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nOs dados vem no formato wide onde cada coluna representa um v√©rtice e cada linha uma curva. Dessa maneira, fa√ßo a convers√£o dos dados para o formato longo com a fun√ß√£o tidyr::pivot_longer.\r\n\r\n\r\nyc_all <- as_tibble(yc_all)\r\n\r\nyc_all_longer <- yc_all |>\r\n  tidyr::pivot_longer(cols = `1 MO`:`30 YR`)\r\n\r\nyc_all_longer\r\n\r\n\r\n# A tibble: 96,384 x 3\r\n   Date       name  value\r\n   <date>     <chr> <dbl>\r\n 1 2022-02-04 1 MO   0.05\r\n 2 2022-02-04 2 MO   0.12\r\n 3 2022-02-04 3 MO   0.23\r\n 4 2022-02-04 6 MO   0.56\r\n 5 2022-02-04 1 YR   0.89\r\n 6 2022-02-04 2 YR   1.31\r\n 7 2022-02-04 3 YR   1.55\r\n 8 2022-02-04 5 YR   1.78\r\n 9 2022-02-04 7 YR   1.9 \r\n10 2022-02-04 10 YR  1.93\r\n# ... with 96,374 more rows\r\n\r\nAqui fa√ßo o tratamento dos dados para converter os prazos em n√∫meros, considerando meses de 30 dias e anos de 360 dias.\r\n\r\n\r\nlibrary(stringr)\r\n\r\nn <- str_match(yc_all_longer$name, \"\\\\d+\") |> as.numeric()\r\np <- str_match(yc_all_longer$name, \"(MO|YR)$\")[, 1]\r\nyc_all_longer$days <- ifelse(p == \"MO\", 30, 360) * n\r\n\r\nyc_all_longer\r\n\r\n\r\n# A tibble: 96,384 x 4\r\n   Date       name  value  days\r\n   <date>     <chr> <dbl> <dbl>\r\n 1 2022-02-04 1 MO   0.05    30\r\n 2 2022-02-04 2 MO   0.12    60\r\n 3 2022-02-04 3 MO   0.23    90\r\n 4 2022-02-04 6 MO   0.56   180\r\n 5 2022-02-04 1 YR   0.89   360\r\n 6 2022-02-04 2 YR   1.31   720\r\n 7 2022-02-04 3 YR   1.55  1080\r\n 8 2022-02-04 5 YR   1.78  1800\r\n 9 2022-02-04 7 YR   1.9   2520\r\n10 2022-02-04 10 YR  1.93  3600\r\n# ... with 96,374 more rows\r\n\r\nAgora fazemos a visualiza√ß√£o.\r\n\r\n\r\nyc_all_longer |>\r\n  mutate(\r\n    year = as.integer(format(Date, \"%Y\")),\r\n    value = value / 100\r\n  ) |>\r\n  filter(year >= 2007) |>\r\n  ggplot(aes(\r\n    x = days, y = value,\r\n    group = Date\r\n  )) +\r\n  geom_line(alpha = 0.2) +\r\n  facet_wrap(. ~ year) +\r\n  labs(\r\n    x = \"Dias Corridos\", y = \"Taxas\",\r\n    title = \"16 anos de Curva Prefixada Americana\",\r\n    caption = \"Fonte: US Treasury (obtidos com \\U1F4E6 Quandl) - wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nJ√° na curva americana, a din√¢mica √© muito mais bem comportada. A parte longo costuma oscilar, mas mantendo a din√¢mica. Os anos 2007, 2008 e 2020, onde tivemos crise do subprime e COVID, trouxeram mais volatilidade.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-18-16-anos-de-curva-prefixada/16-anos-de-curva-prefixada_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-07-18T20:18:38-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1536
  },
  {
    "path": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/",
    "title": "Hist√≥rico de Taxas de Juros em D√≥lar no Brasil",
    "description": "Foi analisado em um post recente a din√¢mica das taxas de juros,\nbrasileira e americana.\nTrago neste post a compara√ß√£o entre as taxas de juros em d√≥lar,\nno Brasil e nos Estados Unidos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-10",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nEm um post recente.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndusd <- yc_usd_mget(\r\n  first_date = \"2019-01-01\",\r\n  last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n  cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\n\r\n\r\nunique(dusd$refdate) |> map(function(date, df) {\r\n  df_curve <- df |>\r\n    filter(refdate == date, cur_days > 0) |>\r\n    filter(!duplicated(cur_days))\r\n  curve <- spotratecurve(\r\n    df_curve$r_360,\r\n    df_curve$cur_days,\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = date\r\n  )\r\n  interpolation(curve) <- interp_flatforward()\r\n  curve\r\n}, df = dusd) -> curves_usd\r\n\r\n\r\n\r\n\r\n\r\ncurves_usd |>\r\n  map_dfr(\\(x) tibble(\r\n    refdate = x@refdate,\r\n    r_USD_br_10y = as.numeric(x[[3600]])\r\n  )) -> rates_usd_10y\r\n\r\n\r\n\r\n\r\n\r\nrates_10y |>\r\n  left_join(rates_usd_10y, by = \"refdate\") |>\r\n  tidyr::pivot_longer(c(r_USD_br_10y, r_USD_us_10y),\r\n    names_to = \"rates\"\r\n  ) |>\r\n  ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n  geom_line() +\r\n  labs(colour = NULL) +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = NULL, y = NULL,\r\n    title = \"Hist√≥rico de Taxas de Juros em D√≥lar de 10 Anos\",\r\n    subtitle = \"Estados Unidos (r_USD_us_10y) e Brasil (r_USD_br_10y)\",\r\n    caption = \"wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent) +\r\n  theme(legend.position = \"bottom\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/histrico-de-taxas-de-juros-em-dlar-no-brasil_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-06-11T06:00:32-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/",
    "title": "Hist√≥rico de Taxas de Juros de Longo Prazo",
    "description": "As taxas de juros de longo prazo s√£o importantes vari√°veis econ√¥micas.\nObservar a din√¢mica dessas taxas √© fundamental para uma boa compreens√£o\ndo cen√°rio econ√¥mico.\nVamos ver como utilizar o pacote {fixedincome} para construir o hist√≥rico da\ntaxa de juros prefixada para o prazo de 10 anos com dados extra√≠dos da B3\ncom o pacote {rb3}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-09",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nNo mercado norte americano h√° cota√ß√µes para taxas de juros em prazos fixos, 1 ano, 5 anos, 10 anos, e assim por diante. Estas estruturas s√£o conhecidas como Constant Term Maturities.\r\nEstes dados podem ser obtidos do site do Tesouro Americano (US Treasury) com o pacote {Quandl}.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nPodemos observar um longo hist√≥rico, desde a d√©cada de 90, para estas taxas.\r\n\r\n\r\nyc_all |>\r\n    ggplot(aes(x = Date, y = `10 YR` / 100)) +\r\n    geom_line() +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Hist√≥rico de Taxas de Juros Americanos de 10 Anos (Treasury Bonds)\",\r\n        caption = \"Dados do US Treasury obtidos com o pacote Quandl - wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nNo mercado brasileiro, infelizmente, a vida √© um pouco miser√°vel, e n√£o h√° um hist√≥rico dispon√≠vel com taxas de longo prazo. √â necess√°rio construir na unha e na for√ßa do √≥dio.\r\nOs ativos l√≠quidos de onde s√£o extra√≠das as taxas de juros de longo prazo s√£o os contratos futuros de taxa DI - DI1, que s√£o cotados diariamente na B3 em seus vencimentos. Entretanto, as taxas de juros obtidas destes contratos apresentam um prazo diferente a cada dia. Assim, √© necess√°rio construir uma curva de juros com estes contratos e realizar uma interpola√ß√£o nos prazos fixos, 1 ano, 5 anos, 10 anos, e por a√≠ vai.\r\nVamos utilizar o pacote {rb3} para obter o hist√≥rico com as curvas di√°rias de juros prefixados do mercado brasileiro e o pacote {fixedincome} para construir os objetos de curvas de juros e realizar a interpola√ß√£o das curvas nos v√©rtices fixos para obter o hist√≥rico de taxas de juros de longo prazo.\r\nVamos come√ßar importando os pacotes utilizados nessa jornada.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(fixedincome)\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\nA fun√ß√£o rb3::yc_mget retorna um data.frame com o hist√≥rico de curvas de juros. Vamos baixar um hist√≥rico desde 2019.\r\n\r\n\r\ndc <- yc_mget(\r\n    first_date = \"2019-01-01\",\r\n    last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n    cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\nDe posse do hist√≥rico, vamos construir as curvas de juros para cada data de refer√™ncia utilizando a fun√ß√£o fixedincome::spotratecurve. A curva de juros prefixada tem as seguintes caracter√≠sticas:\r\nregime de capitaliza√ß√£o: discrete (juros compostos)\r\nregra de contagem de dias: business/252\r\ncalend√°rio: Brazil/ANBIMA\r\ninterpola√ß√£o: flat-forward\r\nAdicionalmente fa√ßo uma limpeza nos eventuais problemas encontrados nos dados, como dias √∫teis zerados e duplicados. Bem, √© de gra√ßa, exigir dados corretos deve ser um pouco demais, n√©?\r\n\r\n\r\nunique(dc$refdate) |> map(function(date, df) {\r\n    df_curve <- df |>\r\n        filter(refdate == date, biz_days > 0) |>\r\n        filter(!duplicated(biz_days))\r\n    curve <- spotratecurve(\r\n        df_curve$r_252,\r\n        df_curve$biz_days,\r\n        \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n        refdate = date\r\n    )\r\n    interpolation(curve) <- interp_flatforward()\r\n    curve\r\n}, df = dc) -> curves\r\n\r\n\r\n\r\nObtendo um lista com as curvas de juros utilizamos os colchetes [[ para realizar a interpola√ß√£o no prazo fixo de 10 anos. Como estas curvas utilizam a regra de contagem de dias business/252, devemos considerar que 1 ano tem 252 dias √∫teis e portanto, 10 anos tem 2520 dias √∫teis. Por isso, interpolamos a curva no v√©rtice 2520.\r\n\r\n\r\ncurves |>\r\n    map_dfr(\\(x) tibble(\r\n        refdate = x@refdate,\r\n        r_BRL_10y = as.numeric(x[[2520]])\r\n    )) -> rates_10y\r\n\r\n\r\n\r\nJ√° aproveito e retorno o hist√≥rico em um data.frame com as colunas refdate e r_BRL_10y. Fa√ßo isso para juntar com os dados de juros americanos de 10 anos e assim comparar a din√¢mica das taxas conjuntamente.\r\n\r\n\r\nrates_10y <- rates_10y |>\r\n    left_join(yc_all |> select(Date, `10 YR`), by = c(\"refdate\" = \"Date\")) |>\r\n    rename(r_USD_us_10y = `10 YR`) |>\r\n    mutate(r_USD_us_10y = r_USD_us_10y / 100)\r\n\r\n\r\n\r\nNote que eu nomeio a taxa de juros americana com r_USD_us_10y, pois essa √© uma taxa que capitaliza o d√≥lar (USD) nos Estados Unidos (us). Abaixo fa√ßo um malabarismo com tidyr::pivot_longer para preparar os dados para o ggplot e assim visualiz√°-los lado a lado. Note ainda que libero a escala dos gr√°ficos (scales = \"free_y\") para que a diferen√ßa de n√≠vel entre as taxas de juros, brasileira e americana, n√£o afete a an√°lise. O objetivo √© visualizar a din√¢mica das taxas de juros ao longo do tempo.\r\n\r\n\r\nrates_10y |>\r\n    tidyr::pivot_longer(\r\n        c(r_BRL_10y, r_USD_us_10y),\r\n        names_to = \"rates\"\r\n    ) |>\r\n    ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n    geom_line() +\r\n    facet_wrap(. ~ rates, scales = \"free_y\") +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Hist√≥rico de Taxas de Juros de 10 Anos\",\r\n        subtitle = \"Americanos (r_USD_us_10y) e Brasileiro (r_BRL_10y)\",\r\n        caption = \"wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent) +\r\n    theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/histrico-de-taxas-de-juros-de-longo-prazo_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-06-10T08:32:29-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/",
    "title": "Curva de Juros de Americana - US Treasuries Curve",
    "description": "Como construir a curva de juros americana utilizando dados do Tesouro\nAmericano (US Treasury) e o pacote {fixedincome}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-06",
    "categories": [
      "R",
      "fixedincome",
      "opendata"
    ],
    "contents": "\r\nA curva de juros americana √© uma pe√ßa fundamental do quebra-cabe√ßas econ√¥mico/financeiro. Neste post vamos ver como obter os dados do hist√≥rico da estrutura a termo de juros dos Estados Unidos e como construir uma curva de juros utilizando o pacote {fixedincome}.\r\nVamos utilizar o Quandl, que hoje √© o Nasdaq Data Link, para obter o hist√≥rico de juros americanos.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nyc_all traz todo o hist√≥rico de juros, as Constant Maturity Treasury rates, que relacionam as taxas de juros ao um conjuto de prazos padronizados: 1, 3, e 6 meses, e 1, 2, 3, 5, 7, 10, 20, e 30 anos.\r\n\r\n\r\nhead(yc_all)\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78 1.90  1.93  2.29\r\n2 2022-02-03 0.03 0.15 0.20 0.48 0.78 1.19 1.42 1.66 1.78  1.82  2.20\r\n3 2022-02-02 0.04 0.10 0.19 0.45 0.76 1.16 1.38 1.60 1.74  1.78  2.17\r\n4 2022-02-01 0.04 0.10 0.19 0.48 0.78 1.18 1.39 1.63 1.76  1.81  2.19\r\n5 2022-01-31 0.03 0.13 0.22 0.49 0.78 1.18 1.39 1.62 1.75  1.79  2.17\r\n6 2022-01-28 0.04 0.10 0.19 0.43 0.75 1.15 1.38 1.61 1.74  1.78  2.14\r\n  30 YR\r\n1  2.23\r\n2  2.14\r\n3  2.11\r\n4  2.12\r\n5  2.11\r\n6  2.07\r\n\r\nVamos montar a curva de juros para uma data espec√≠fica utilizando os prazos definidos no hist√≥rico.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nrefdate <- as.Date(\"2022-02-04\")\r\nyc <- yc_all |> filter(Date == refdate)\r\n\r\nyc\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78  1.9  1.93  2.29\r\n  30 YR\r\n1  2.23\r\n\r\nComecemos construindo o vetor de prazos da curva. Para isso precisamos interpretar os nomes das colunas e convert√™-los em prazos.\r\n\r\n\r\nnx <- names(yc)\r\nterms_names <- nx[-1]\r\nterms_names\r\n\r\n\r\n [1] \"1 MO\"  \"2 MO\"  \"3 MO\"  \"6 MO\"  \"1 YR\"  \"2 YR\"  \"3 YR\"  \"5 YR\" \r\n [9] \"7 YR\"  \"10 YR\" \"20 YR\" \"30 YR\"\r\n\r\nTemos MO indicando prazos em meses e YR indicando os anos. Vamos utilizar uma simples substitui√ß√£o de texto para converter MO para months e YR para years. Dessa forma podemos utilizar a fun√ß√£o fixedincome::as.term que converte um string em um objeto term (prazo).\r\n\r\n\r\nlibrary(stringr)\r\n\r\nterms_names <- terms_names |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\")\r\n\r\nterms_names\r\n\r\n\r\n [1] \"1 months\" \"2 months\" \"3 months\" \"6 months\" \"1 years\"  \"2 years\" \r\n [7] \"3 years\"  \"5 years\"  \"7 years\"  \"10 years\" \"20 years\" \"30 years\"\r\n\r\nAp√≥s a convers√£o usamos a fun√ß√£o purrr::map com a fun√ß√£o fixedincome::as.term e assim vamos obter uma lista com diversos objetos term.\r\n\r\n\r\nlibrary(purrr)\r\nlibrary(fixedincome)\r\n\r\ncurve_terms <- map(terms_names, as.term)\r\ncurve_terms\r\n\r\n\r\n[[1]]\r\n[1] \"1 month\"\r\n\r\n[[2]]\r\n[1] \"2 months\"\r\n\r\n[[3]]\r\n[1] \"3 months\"\r\n\r\n[[4]]\r\n[1] \"6 months\"\r\n\r\n[[5]]\r\n[1] \"1 year\"\r\n\r\n[[6]]\r\n[1] \"2 years\"\r\n\r\n[[7]]\r\n[1] \"3 years\"\r\n\r\n[[8]]\r\n[1] \"5 years\"\r\n\r\n[[9]]\r\n[1] \"7 years\"\r\n\r\n[[10]]\r\n[1] \"10 years\"\r\n\r\n[[11]]\r\n[1] \"20 years\"\r\n\r\n[[12]]\r\n[1] \"30 years\"\r\n\r\nObviamente tudo isso poderia ter sido feito de forma direta.\r\n\r\n\r\ncurve_terms <- nx[-1] |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\") |>\r\n  map(as.term)\r\n\r\n\r\n\r\nPois bem, temos uma lista com prazos em meses e prazos em anos. √â necess√°rio converter os prazos para uma mesma unidade (units). Vou converter todos os prazos para dias. Para fazer isso vou criar um objeto daycount(\"actual/360\"), que √© a regra de contagem de dias que considera dias corridos e anos com 360 dias. Com a regra de contagem de dias conseguimos fazer a convers√£o dos prazos para anos e utilizando a quantidade de dias no ano da regra, 360, fazemos a convers√£o para dias.\r\n\r\n\r\ndc <- daycount(\"actual/360\")\r\n\r\nterms <- curve_terms |>\r\n    map_dbl(\\(x) dib(dc) * toyears(dc, x)) |>\r\n    term(\"days\")\r\n\r\nterms\r\n\r\n\r\n [1] \"30 days\"    \"60 days\"    \"90 days\"    \"180 days\"   \"360 days\"  \r\n [6] \"720 days\"   \"1080 days\"  \"1800 days\"  \"2520 days\"  \"3600 days\" \r\n[11] \"7200 days\"  \"10800 days\"\r\n\r\nA fun√ß√£o fixedincome::toyears converte os prazos para um n√∫mero em anos, por exemplo, 6 meses retorna 0.5, e a fun√ß√£o dib retorna a quantidade de dias no ano para a regra, neste caso, 360. Conclu√≠mos criando os objetos de prazo com term.\r\nAgora que j√° temos os prazos da curva vamos extrair as taxas do data.frame. √â uma opera√ß√£o simples de extra√ß√£o de linhas de um data.frame e converter em um vetor. Fazemos uma verifica√ß√£o de NA por que eventualmente h√° podemos ter valores ausentes para alguns prazos.\r\n\r\n\r\nrates <- yc[1, -1] |>\r\n    as.list() |>\r\n    as.numeric()\r\nrates <- rates / 100\r\nix <- !is.na(rates)\r\n\r\nrates[ix]\r\n\r\n\r\n [1] 0.0005 0.0012 0.0023 0.0056 0.0089 0.0131 0.0155 0.0178 0.0190\r\n[10] 0.0193 0.0229 0.0223\r\n\r\nTendo os prazos, as taxas e a data de refer√™ncia, podemos construir a curva com a fun√ß√£o fixedincome::spotratecurve. Para a curva de juros americana utilizamos taxa de juros simples (compounding simple), regra de contagem de dias (actual/360) e o calend√°rio de dias corridos (actual).\r\n\r\n\r\ntr_curve <- spotratecurve(\r\n    rates[ix], terms[ix],\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = refdate\r\n)\r\n\r\ntr_curve\r\n\r\n\r\n          SpotRateCurve\r\n30 days          0.0005\r\n60 days          0.0012\r\n90 days          0.0023\r\n180 days         0.0056\r\n360 days         0.0089\r\n720 days         0.0131\r\n1080 days        0.0155\r\n1800 days        0.0178\r\n2520 days        0.0190\r\n3600 days        0.0193\r\n# ... with 2 more rows\r\nsimple actual/360 actual \r\nReference date: 2022-02-04 \r\n\r\nNote os prazos em dias. Agora √© s√≥ visualizar a curva de forma graciosa!\r\n\r\n\r\nplot(tr_curve)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/curva-de-juros-de-americana-us-treasuries-curve_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2022-06-08T06:41:20-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-05-indicadores-da-pesquisa-focus/",
    "title": "Indicadores da Pesquisa Focus",
    "description": "As APIs de Expectativas de Mercado da Pesquisa Focus n√£o informam\ndireito quais indicadores est√£o dispon√≠veis. A documenta√ß√£o √© meio falha e\npouco confi√°vel. Dessa maneira, a √∫nica maneira de descobrir o que est√°\ndispon√≠vel √© investigando a API. √â isso que vou mostrar como fazer neste post.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-05",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFun√ß√£o get_market_expectations\r\nDescobrindo indicadores dispon√≠veis\r\nannual\r\nmonthly\r\nquarterly\r\ninflation-12-months\r\ntop5s-annual\r\ntop5s-monthly\r\ntop5s-selic\r\nselic\r\ninstitutions\r\n\r\nConclus√£o\r\n\r\n√â poss√≠vel obter as expectativas de mercado para diversos indicadores macroecon√¥micos da pesquisa Focus de forma totalmente autom√°tica utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} √© uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroecon√¥micos da pesquisa Focus s√£o consolidadas em estat√≠sticas di√°rias e divulgadas na API. Estas estat√≠sticas s√£o calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais institui√ß√µes do mercado financeiro. Os indicadores macroecon√¥micos s√£o referentes a √≠ndices de pre√ßos, crescimento do PIB e da produ√ß√£o industrial, taxa de c√¢mbio, taxa Selic, vari√°veis fiscais e indicadores do setor externo e s√£o publicadas todo primeiro dia √∫til da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFun√ß√£o get_market_expectations\r\nA fun√ß√£o get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se n√£o for informado o valor annual ser√° utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroecon√¥micos\r\ninflation-12-months para expectativas de infla√ß√£o nos pr√≥ximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas institui√ß√µes credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroecon√¥mico, √© opcional, de forma, quando n√£o for definido, todos os indicadores dispon√≠veis para o endpoint ser√£o retornados. Esse ponto √© curioso, pois a documenta√ß√£o n√£o √© boa e informa indicadores que n√£o s√£o mais disponibilizados.\r\nstart_date e end_date definem as datas de in√≠cio e fim para a consulta, s√£o opcionais e caso n√£o sejam informados, todo o per√≠odo ser√° retornado, o que n√£o √© recomendado pois onera os servi√ßos de dados do BCB que j√° n√£o s√£o l√° os melhores.\r\nkeep_names √© um argumento utilizado internamente que n√£o faz diferen√ßa para o usu√°rio final.\r\n... aqui s√£o passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'Jo√£o'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no come√ßo que n√£o devem ser retornadas\r\n$top define a quantidade de linhas que ser√£o retornadas\r\n\r\nDescobrindo indicadores dispon√≠veis\r\nPara descobrir os indicadores macroecon√¥micos dispon√≠veis para um determinado endpoint √© necess√°rio realizar duas consultas. A primeira para descobrir a data mais recente com dados, pois a disponibilidade dos indicadores varia com o tempo, de maneira que temos indicadores mais recentes que n√£o est√£o no hist√≥rico antigo. Tendo esta data, realizamos a segunda consulta filtrando por esta data.\r\nVamos fazer isso para cada um dos endpoints.\r\nannual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nEste endpoint tem uma coluna IndicadorDetalhe, que √© como uma especifica√ß√£o do indicador. No caso, Balan√ßa Comercial-Saldo ou Balan√ßa Comercial-Exporta√ß√µes, por exemplo.\r\nmonthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nquarterly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninflation-12-months\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-annual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-monthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-selic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$select` = \"Data,indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(indicador) |>\r\n  arrange(indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nAqui temos uma pegadinha, a coluna indicador vem com sua inicial min√∫scula, diferente dos demais endpoints.\r\nselic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninstitutions\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2021-05-31'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConclus√£o\r\nObservamos que para a maior parte dos endpoints, todos exceto institutions, a √∫ltima data dispon√≠vel √© a mesma, indicando que as estat√≠sticas s√£o atualizadas conjuntamente.\r\nO endpoint institutions est√° com √∫ltima data em aproximadamente 1 ano atr√°s, o que me faz conjecturar que estes dados podem ser divulgados com 1 ano de atraso.\r\nUma vez que conhecemos os indicadores dispon√≠veis podemos utilizar o argumento indic para selecionar o indicador desejado na consulta.\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        indic = c(\"IPCA\", \"IGP-M\"),\r\n                        start_date = \"2022-04-29\",\r\n                        `$select` = \"Data,Indicador,DataReferencia,Media,baseCalculo\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-05T08:09:03-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-06-03-expectativas-focus-com-rbcb/",
    "title": "Expectativas de Mercado da Pesquisa Focus no R",
    "description": "Obtendo as expectativas de mercado para os indicadores macroecon√¥micos da\nPesquisa Focus utilizando o R e o pacote {rbcb}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-03",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFun√ß√£o get_market_expectations\r\nConhecendo os valores retornados\r\nRealizando uma consulta mais elaborada\r\nVisualizando os dados\r\nS√©rie temporal das expectativas de IPCA\r\nS√©rie temporal com intervalo informado\r\n\r\n\r\n√â poss√≠vel obter as expectativas de mercado para diversos indicadores macroecon√¥micos da pesquisa Focus de forma totalmente autom√°tica utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} √© uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroecon√¥micos da pesquisa Focus s√£o consolidadas em estat√≠sticas di√°rias e divulgadas na API. Estas estat√≠sticas s√£o calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais institui√ß√µes do mercado financeiro. Os indicadores macroecon√¥micos s√£o referentes a √≠ndices de pre√ßos, crescimento do PIB e da produ√ß√£o industrial, taxa de c√¢mbio, taxa Selic, vari√°veis fiscais e indicadores do setor externo e s√£o publicadas todo primeiro dia √∫til da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFun√ß√£o get_market_expectations\r\nA fun√ß√£o get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se n√£o for informado o valor annual ser√° utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroecon√¥micos\r\ninflation-12-months para expectativas de infla√ß√£o nos pr√≥ximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas institui√ß√µes credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroecon√¥mico, √© opcional, de forma, quando n√£o for definido, todos os indicadores dispon√≠veis para o endpoint ser√£o retornados. Esse ponto √© curioso, pois a documenta√ß√£o n√£o √© boa e informa indicadores que n√£o s√£o mais disponibilizados.\r\nstart_date e end_date definem as datas de in√≠cio e fim para a consulta, s√£o opcionais e caso n√£o sejam informados, todo o per√≠odo ser√° retornado, o que n√£o √© recomendado pois onera os servi√ßos de dados do BCB que j√° n√£o s√£o l√° os melhores.\r\nkeep_names √© um argumento utilizado internamente que n√£o faz diferen√ßa para o usu√°rio final.\r\n... aqui s√£o passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'Jo√£o'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no come√ßo que n√£o devem ser retornadas\r\n$top define a quantidade de linhas que ser√£o retornadas\r\n\r\nConhecendo os valores retornados\r\nCada endpoint possui o seu conjuto de colunas retornadas e isso pode mudar com o tempo, dessa maneira, para conhecer cada API, eu recomendo fortemente que a op√ß√£o $top = 10 seja utilizada para limitar uma consulta inicial para conhecimento dos valores retornados.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nComo vemos, tem muito NA. Talvez seja por que estamos visualizando dados muito antigos, vamos reordenar para trazer os dados mais recentes. Para isso √© necess√°rio definir a op√ß√£o $orderby.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10,\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nJ√° ficou melhor, j√° √© poss√≠vel entender as informa√ß√µes retornadas.\r\nRealizando uma consulta mais elaborada\r\nPodemos definir melhor a consulta e o que queremos dela:\r\nretornar as colunas: Data, DataReferencia, Media, Mediana, Maximo, Minimo e DesvioPadrao. Para isso vamos utilizar a op√ß√£o $select.\r\nfiltrar baseCalculo igual a 0 e DataReferencia igual a 2021 ou 2022 com a op√ß√£o $filter.\r\nCom data inicial igual a 2020-12-01, para pegar os dados desde dezembro de 2020\r\n\r\n\r\ndf <- get_market_expectations(\"annual\",\r\n                              indic = \"IPCA\",\r\n                              start_date = \"2020-12-01\",\r\n                              `$filter` = \"(DataReferencia eq '2021' or DataReferencia eq '2022') and baseCalculo eq 0\",\r\n                              `$select` = \"Data,DataReferencia,Media,Mediana,DesvioPadrao,Maximo,Minimo\")\r\ndf |> head() |> rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nVisualizando os dados\r\nCom as estat√≠sticas de expectativas de IPCA carregadas podemos come√ßar a visualiza√ß√£o dos dados. Estas expectativas s√£o referentes a infla√ß√£o cheia para os anos de 2021 e 2022 (DataReferencia). O filtro baseCalculo igual a 1 refere-se ao prazo de validade das expectativas informadas. Esta coluna pode ser 0 ou 1. baseCalculo igual a 0 considera as expectativas informadas nos √∫ltimos 30 dias no c√°lculo das estat√≠sticas e baseCalculo igual a 1 considera os √∫ltimos 4 dias. Foi escolhida baseCalculo igual a 0 por ter uma amostra maior, consequ√™ncia do per√≠odo maior.\r\nS√©rie temporal das expectativas de IPCA\r\nVamos come√ßar observando a s√©rie temporal das expectativas para cada DataReferencia.\r\n\r\n\r\ndf |>\r\n  ggplot(aes(x = Data, y = Mediana, group = DataReferencia, colour = DataReferencia)) +\r\n  geom_line() +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021 e 2022\",\r\n    subtitle = \"M√©dia das expectativas de IPCA\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Infla√ß√£o\"\r\n  )\r\n\r\n\r\n\r\n\r\nCurioso ver como as expectativas de infla√ß√£o para 2021 mudaram ao longo de 2021, ou seja, erra-se miseravelmente. As expectativas para 2022 mudam menos, bem, isso at√© virar o ano.\r\nS√©rie temporal com intervalo informado\r\nVamos olhar agora apenas a DataReferencia 2021 e colocar as linhas de m√°ximo e m√≠nimo para termos uma ideia de intervalo para as expectativas.\r\n\r\n\r\ndf |>\r\n  filter(DataReferencia == 2021) |>\r\n  ggplot(aes(x = Data)) +\r\n  geom_line(aes(y = Mediana), colour = \"black\") +\r\n  geom_line(aes(y = Maximo), colour = \"grey\") +\r\n  geom_line(aes(y = Minimo), colour = \"grey\") +\r\n  geom_ribbon(aes(ymin = Minimo, ymax = Maximo), fill = \"blue\", alpha = 0.3) +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021\",\r\n    subtitle = \"M√©dia das expectativas de IPCA com intervalo definido por m√°ximo e m√≠nimo da amostra\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Infla√ß√£o\"\r\n  )\r\n\r\n\r\n\r\n\r\nInteressante ver como as pesquisas erram e como, mesmo os mais ousados, n√£o saem muito do consenso. Entendo que esse √© um mecanismo necess√°rio para se colocar o ‚Äúbode na sala‚Äù, entretanto, erra-se miseravelmente, s√£o muitos vieses envolvidos.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-03-expectativas-focus-com-rbcb/expectativas-focus-com-rbcb_files/figure-html5/ipca-mediana-desviopadrao-1.png",
    "last_modified": "2022-06-05T06:59:27-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/",
    "title": "Gr√°ficos de Composi√ß√£o de √çndices da B3",
    "description": "Com o pacote {rb3} √© poss√≠vel obter a composi√ß√£o dos √≠ndices da B3,\ncomo o IBOVESPA, por exemplo. Vamos construir alguns gr√°ficos donuts\npara avaliarmos a distribui√ß√£o da composi√ß√£o dos √≠ndices.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-01",
    "categories": [
      "R",
      "rb3",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nIBOVESPA\r\nIBX 100\r\nIBX 50\r\nSMALL\r\nIFIX\r\n\r\nRecentemente, eu implementei no pacote {rb3} um conjunto de fun√ß√µes que baixam dados de √≠ndices do site da B3.\r\nVou mostrar aqui como utilizar a fun√ß√£o rb3::index_weights_get, que retorna um data.frame com todas as a√ß√µes que comp√µem um determinado √≠ndice, juntamente com os seus respectivos pesos no √≠ndice.\r\nVamos come√ßar carregando os pacotes {rb3} e {tidyverse} que utilizo.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\n\r\n\r\nheight <- 7.5\r\nwidth <- 7.5\r\n\r\n\r\n\r\nA ideia aqui √© avaliar a distribui√ß√£o de ativos em alguns √≠ndices, a saber: IBOV, IBXX, IBXL, SMLL e IFIX. Contudo, essa avalia√ß√£o ser√° realizada da seguinte forma: os 10 ativos com a maior participa√ß√£o nos √≠ndices ser√£o selecionados e os demais ativos ser√£o colocado em um grupo definido como Others. Assim vou fazer um gr√°fico de donut (uma pizza com furo no meio) apresentando a participa√ß√£o de cada ativo no √≠ndice. Dessa maneira ser√° poss√≠vel avaliar a concentra√ß√£o dos √≠ndices.\r\nPara fazer essa sele√ß√£o dos ativos e o agrupemento dos demais eu criei a fun√ß√£o top_weight. Esta fun√ß√£o j√° prepara o data.frame para a fun√ß√£o ggdonut que constroi o gr√°fico de donut.\r\n\r\n\r\ntop_weight <- function(.data, n = 10) {\r\n    top_10 <- .data |>\r\n        arrange(desc(weight)) |>\r\n        slice_head(n = n) |>\r\n        select(symbol, weight)\r\n    total_weight <- sum(top_10$weight)\r\n    others <- tibble(\r\n        symbol = \"Others\",\r\n        weight = 1 - total_weight\r\n    )\r\n\r\n    bind_rows(top_10, others) |>\r\n        mutate(cum_weight = cumsum(weight)) |>\r\n        mutate(\r\n            ymax = cum_weight,\r\n            ymin = c(0, head(cum_weight, n = -1)),\r\n            label_pos = (ymax + ymin) / 2,\r\n            label = paste0(symbol, \"\\n\", scales::percent(weight)),\r\n            symbol = factor(symbol, ordered = TRUE)\r\n        )\r\n}\r\n\r\nggdonut <- function(.data, index_name) {\r\n    ggplot(.data, aes(\r\n        ymax = ymax, ymin = ymin,\r\n        xmax = 4, xmin = 3,\r\n        fill = symbol\r\n    )) +\r\n        geom_rect(colour = \"white\") +\r\n        geom_label(\r\n            x = 4.5, aes(y = label_pos, label = label), size = 3\r\n        ) +\r\n        annotate(\r\n            \"text\",\r\n            x = 0, y = 0, label = index_name, size = 16, colour = \"grey\",\r\n            fontface = 2\r\n        ) +\r\n        coord_polar(theta = \"y\") +\r\n        scale_fill_brewer(palette = \"Set3\") +\r\n        scale_color_brewer(palette = \"Set3\") +\r\n        xlim(c(0, 4)) +\r\n        theme_void() +\r\n        theme(legend.position = \"none\") +\r\n        labs(\r\n            caption = \"Source: B3 (data imported using \\U1F4E6 rb3) - wilsonfreitas\"\r\n        )\r\n}\r\n\r\n\r\n\r\nIBOVESPA\r\n\r\n\r\nindex_name <- \"IBOV\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIBX 100\r\n\r\n\r\nindex_name <- \"IBXX\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIBX 50\r\n\r\n\r\nindex_name <- \"IBXL\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nSMALL\r\n\r\n\r\nindex_name <- \"SMLL\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIFIX\r\n\r\n\r\nindex_name <- \"IFIX\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/grficos-de-composio-de-ndices-da-b3_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-06-13T11:05:26-03:00",
    "input_file": {},
    "preview_width": 1440,
    "preview_height": 1440
  },
  {
    "path": "posts/2022-01-17-dados-bcb-com-python/",
    "title": "Obtendo Dados do BCB com Python",
    "description": "Obter os dados para an√°lise de forma simples √© fundamental e necess√°rio.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-01-17",
    "categories": [
      "Python",
      "bcb",
      "opendata"
    ],
    "contents": "\r\nObter os dados para an√°lise de forma simples √© fundamental e necess√°rio.\r\nDepois de passar alguns anos mantendo o pacote {rbcb} que faz a integra√ß√£o do R com as APIs de dados abertos do Banco Central, decidi fazer o port para Python.\r\nEm parte porque o PyPI (Python Package Index - reposit√≥rio de pacotes do Python) √© bem menos burocr√°tico que o CRAN (reposit√≥rio de pacote do R), mas nos √∫ltimos anos tenho mexido mais com Python e fazia sentido portar algumas ferramentas.\r\nO pacote {python-bcb} √© a contraparte em Python do pacote {rbcb} do R.\r\nS√≥ que acabou ficando maior, n√£o por causa do Python, mas por que eu estava com tempo e paci√™ncia e acabei implementando parte da especifica√ß√£o OData. Isso permite de forma bem simples integrar diversas APIs do Banco Central que implementam essa especifica√ß√£o. Na minha √∫ltima contagem tinha 39 APIs nessa estrutura.\r\nO pacote {python-bcb} traz as seguintes APIs:\r\nSGS\r\nS√©ries de Moedas do Conversor de Moedas do Banco Central\r\nExpectativas do FOCUS\r\nBoletins da PTAX (abertura, 3 intradi√°rios, fechamento)\r\nDados selecionados de institui√ß√µes financeiras (IFDATA)\r\nAgora o que d√° mais trabalho ao fazer a integra√ß√£o de uma API √© escrever a documenta√ß√£oüòâ dado que as APIs n√£o s√£o padronizadas.\r\nVou comunicando aqui na medida que novas APIs forem sendo integradas.\r\nObviamente espero todo o tipo de coment√°rios e sugest√µes.\r\nDocumenta√ß√£o do projeto: https://wilsonfreitas.github.io/python-bcb/index.html\r\nLink do projeto: https://github.com/wilsonfreitas/python-bcb\r\nNa imagem segue um exemplo que como utilizar a API de Expectativas do FOCUS para obter um DataFrame das expectativas de IPCA de 2021 ao longo de 2021.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-01-17-dados-bcb-com-python/expectativas.png",
    "last_modified": "2022-06-03T06:11:37-03:00",
    "input_file": {},
    "preview_width": 1328,
    "preview_height": 856
  }
]
