[
  {
    "path": "posts/2022-08-29-dinamica-da-volatilidade-implicita/",
    "title": "Dinâmica da Volatilidade Implícita",
    "description": "Como a volatilidade implícita das opções evolui no tempo? Há diversas formas de se avaliar isso.\nAqui veremos como é a dinâmica na volatilidade das opções ATM no tempo.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-08-29",
    "categories": [],
    "contents": "\r\nHá divesos estudos sobre o comportamento das opções e sobre quais fatores são mais importantes para explicar as suas mudanças de preços. Sabemos que, depois do ativo objeto, a volatilidade implícita é a variável que mais influiencia nas variações de preços das opções. Dessa forma, é importante entender como se dão as suas variações, de outra forma, é importante conhecer a sua dinâmica.\r\nAqui vou carregar o histórico de opções de PETR4 desde o começo de 2022, calcular a volatilidade implícita e o delta para cada uma das opções, e para cada data de referência, selecionar as opções, call e put, mais próximas da data de vencimento e com o delta mais próximo de 50%.\r\nAssim teremos uma opção, para cada tipo, call e put, em cada data de referência. Dessa maneira, é possível construir uma série temporal de volatilidade implícita por tipo de opção.\r\nAs opções mais próximas do vencimento (ou primeiro vencimento), apresentam a maior liquidez dentre as opções negociadas. Aqui estamos selecionando o primeiro vencimento até a sua expiração, entretanto, é interessante que seja realizada uma análise da liquidez das opções a medida que se aproximam do vencimento para que uma estratégia de rolagem seja definida. Pois, na medida que o primeiro vencimento se aproxima, a liquidez migra para o segundo vencimento. O desafio é identificar a dinâmica dessa migração. Aqui isso não será levado em consideração, vamos carregar as opções do primeiro vencimento até a sua expiração.\r\nComeçando com o carregamento de pacotes.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(oplib)\r\nlibrary(bizdays)\r\nlibrary(tidyverse)\r\n\r\n\r\nAs opções são carregadas via o arquivo COTAHIST (rb3::cotahist_get) e as curvas de juro são baixadas do site da B3 na página de Taxas de Referência (rb3::yc_mget).\r\n\r\n\r\nrefdate <- getdate(\"last bizday\", Sys.Date(), \"Brazil/B3\")\r\nch <- cotahist_get(refdate, \"yearly\")\r\nyc <- yc_mget(first_date = as.Date(\"2022-01-01\"), last_date = refdate)\r\n\r\n\r\nVamos utilizar a função rb3::cotahist_options_by_symbol_superset para obter o super dataset para opções de PETR4. De posse do super dataset, os dados de vencimento e taxas de juros são formatados para o cálculo da volatilidade implícita e do delta para todas as opções.\r\n\r\n\r\nsymbol <- \"PETR4\"\r\n\r\nop <- cotahist_options_by_symbol_superset(symbol, ch, yc)\r\n\r\nop_vol <- op |>\r\n  mutate(\r\n    biz_days = bizdays(\r\n      refdate, following(maturity_date, \"Brazil/B3\"), \"Brazil/B3\"\r\n    ),\r\n    time_to_maturity = biz_days / 252,\r\n    rate = log(1 + r_252),\r\n    bsm_impvol = bsmimpvol(\r\n      close, type, close.underlying, strike, time_to_maturity, rate, 0\r\n    ),\r\n    delta = bsmdelta(\r\n      type, close.underlying, strike, time_to_maturity, rate, 0, bsm_impvol\r\n    )\r\n  ) |>\r\n  select(\r\n    refdate, symbol, volume, maturity_date,\r\n    type, close.underlying, strike, time_to_maturity, rate,\r\n    biz_days, close, high, low, bsm_impvol, delta\r\n  )\r\n\r\n\r\nDinâmica da Volatilidade ATM\r\nComo todos os cálculos realizados vamos selecionar as opções ATM do primeiro vencimento para cada data de referência. Fazemos uma segmentação dos dados por refdate e para cada chunk selecionamos o primeiro vencimento.\r\n\r\n\r\nop1 <- op_vol |>\r\n  split(op_vol$refdate) |>\r\n  map_dfr(function(df) {\r\n    first_mat <- df$maturity_date[which.min(df$maturity_date)]\r\n    filter(df, maturity_date == first_mat)\r\n  })\r\n\r\n\r\nO dataframe op1 tem opções call e put, em diversos strikes, para cada data de referência. Agora precisamos selecionar as opções mais próximas do dinheiro, ou seja, as opções com delta mais próximo de 50%. Como há uma diferença de sinal entre opções call e put, vamos calcular as diferenças em valores absolutos do delta em relação ao valor 0.5 (delta = 50%).\r\n\r\n\r\nop1_atm <- split(op1, op1$refdate) |>\r\n  map_dfr(function(df) {\r\n    df_type <- filter(df, type == \"Put\")\r\n    df1 <- df_type[which.min(abs(abs(df_type$delta) - 0.5)), ]\r\n\r\n    df_type <- filter(df, type == \"Call\")\r\n    df2 <- df_type[which.min(abs(abs(df_type$delta) - 0.5)), ]\r\n\r\n    bind_rows(df1, df2)\r\n  })\r\n\r\n\r\nO dataframe op1_atm tem, para cada data de referência, 1 call ATM e 1 put ATM.\r\nVamos visualizar a série temporal de volatilidades implícitas para estas opções.\r\n\r\n\r\nop1_atm |>\r\n  ggplot(aes(x = refdate, y = bsm_impvol, colour = type)) +\r\n  geom_line() +\r\n  geom_point() +\r\n  facet_wrap(type ~ .) +\r\n  labs(\r\n    x = \"Data\", y = \"Volatilidade Implícita\",\r\n    title = \"Série Histórica Volatilidade Implícita (ATM) - PETR4\",\r\n    subtitle = \"Volatilidade implícita de opções com delta mais próximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"none\")\r\n\r\n\r\n\r\nÉ possível notar que a dinâmica da volatilidade, entre as opções call e put, é bem comportada. Há eventuais momentos de divergência, contudo, o comportamento das duas séries é bastante semelhante. As séries apresentam um forte comportamento de reversão à média, o que é característico desse tipo de variável.\r\nOutro ponto interessante é verificar quais os preços de exercício para as opções ATM selecionadas. Pois, uma vez que o preço do ativo objeto muda, o delta da opção muda e o preço de exercício que representa o delta também muda.\r\n\r\n\r\nop1_atm |>\r\n  ggplot(aes(x = refdate, y = strike, colour = type)) +\r\n  geom_line() +\r\n  geom_point(aes(shape = type), size = 3) +\r\n  labs(\r\n    x = \"Data\", y = \"Strike\",\r\n    title = \"Série Histórica Strikes (ATM) - PETR4\",\r\n    subtitle = \"Preços de exercício de opções com delta mais próximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"top\", legend.title = element_blank())\r\n\r\n\r\n\r\nAqui as séries são praticamente as mesmas, indicando que as opções ATM, calls e puts, possuem os mesmos strikes. Em poucos pontos há uma diferença nos preços de exercício. É interessante que este ponto seja melhor avaliado e talvez a liquidez das opções ajude a explicar estas diferenças.\r\nVamos observar os deltas das opções ATM selecionadas. Uma vez que estamos selecionando opções ATM, é interessante que os deltas estejam próximos de 50%. Mas como se dá essa seleção? No gráfico abaixo vemos que os deltas de calls e puts oscilam em torno de 50% e estão sempre próximos entre si, há poquíssimos casos em que o delta da call está acima de 50% e o delta da put está abaixo de 50%. Novamente, cabe uma melhor investigação para melhor compreender os fatores causadores da divergência.\r\n\r\n\r\nop1_atm |>\r\n  mutate(delta = ifelse(delta < 0, 1 + delta, delta)) |>\r\n  ggplot(aes(x = refdate, y = delta, colour = type)) +\r\n  geom_line() +\r\n  geom_point() +\r\n  labs(\r\n    x = \"Data\", y = \"Delta\",\r\n    title = \"Série Histórica Deltas (ATM) - PETR4\",\r\n    subtitle = \"Delta de opções com delta mais próximo de 50%\",\r\n    caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n  ) +\r\n  theme(legend.position = \"top\", legend.title = element_blank())\r\n\r\n\r\n\r\nUma vez que construímos as séries temporais para a volatilidade de opções ATM, o próximo passo é modelar essa série. Um problema interessante é comparar essa dinâmica com a volatilidade realizada, talvez separando por cada vencimento. Idealmente a volatilidade implícita deveria convergir para a volatilidade realizada. Outro ponto que ficou em aberto e a avaliação da liquidez e sua consequência na estratégia de rolagem. Aqui estamos selecionando as opções mais próximas do ATM para obter as volatilidades. Uma alternativa é fazer o ajuste de um modelo e obter a volatilidade teórica par um delta de 50%. Em geral, como a liquidez se concentra próximo à vizinhança das opções no dinheiro, há bastante informação nessa região para obter um bom modelo ajustado.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-29-dinamica-da-volatilidade-implicita/dinamica-da-volatilidade-implicita_files/figure-html5/op1-vol-atm-1.png",
    "last_modified": "2022-08-29T09:16:09-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-08-17-movimento-da-parte-longa-da-curva-de-juros/",
    "title": "Movimento da Parte Longa da Curva de Juros",
    "description": "A reunião do COPOM no começo do mês de agosto de 2022 trouxe um tom que\ninfluenciou a dinâmica da parte longa da curva de juros.\nAqui apresento uma animação do movimento da curva de juros nas duas primeiras semanas de agosto\nde 2022.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-08-17",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nA reunião do COPOM de 3 de agosto trouxe uma mudança na estrutura da curva de juros, tanto para a parte curta como para a parte longa. A interpretação do comunicado por agentes de mercado é de o ciclo de alta de juros está próximo do fim.\r\nNa prática a dinâmica da parte longa da curva de juros foi bastante afetada. Aqui apresento uma animação onde observa-se o movimento da curva de juros nas duas primeiras semanas do mês de agosto de 2022. A reunião do COPOM aconteceu em 3 de agosto. Fica claro pela animação a mudança nas expectativas de longo prazo para a curva.\r\nVamos utilizar o 📦 {rb3} para obter as curvas e o 📦 {fixedincome} na construção dos gráficos da estrutura a termo de juros. A animação é construida com o 📦 {animation}.\r\n\r\n\r\nlibrary(fixedincome)\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\n\r\nget_di1_curve <- function(refdate) {\r\n  fut <- futures_get(refdate)\r\n  yc <- yc_get(refdate)\r\n  df <- yc_superset(yc, fut)\r\n\r\n  df_curve <- bind_rows(\r\n    df |> slice(1) |> select(biz_days, r_252),\r\n    df |> filter(!is.na(symbol)) |> select(biz_days, r_252)\r\n  ) |>\r\n    filter(!duplicated(biz_days))\r\n\r\n  spotratecurve(\r\n    df_curve$r_252, df_curve$biz_days, \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n    refdate = refdate\r\n  )\r\n}\r\n\r\n\r\nVamos obter as curvas para os dias úteis entre 2022-08-01 e 2022-08-16 e colocá-las em uma lista. Na sequência a animação será construída com cada uma das curvas da lista, sendo que a primeira curva tem a cor vermelha e a última tem cor azul, as demais curvas são em cinza. O objetivo é acompanhar a evolução das curvas tendo em destaque o começo e fim.\r\n\r\n\r\ndates <- bizseq(\"2022-08-01\", \"2022-08-16\", \"Brazil/ANBIMA\")\r\ncurves <- lapply(seq_along(dates), function(ix) get_di1_curve(dates[ix]))\r\n\r\nanim <- animation::saveGIF(\r\n  {\r\n    g <- autoplot(curves[[1]], curve.x.axis = \"terms\", colour = \"red\") +\r\n      autolayer(curves[[1]], curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"red\") +\r\n      ylim(0.11, 0.14) +\r\n      theme_bw() +\r\n      theme(legend.position = \"none\") +\r\n      labs(\r\n        x = \"Prazos\", y = NULL, title = \"Curvas de Juros Prefixados DI1\",\r\n        subtitle = \"Entre as datas 2022-08-01 e 2022-08-16\",\r\n        caption = \"Desenvolvido por wilsonfreitas / Fonte: B3\"\r\n      )\r\n    print(g)\r\n\r\n    for(curve in curves[-c(1, length(curves))]) {\r\n      g <- g + autolayer(curve, curve.x.axis = \"terms\", colour = \"grey\") +\r\n        autolayer(curve,\r\n          curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"grey\"\r\n        )\r\n      print(g)\r\n    }\r\n\r\n    g <- g + autolayer(curves[[length(curves)]], curve.x.axis = \"terms\", colour = \"blue\") +\r\n      autolayer(curves[[length(curves)]],\r\n        curve.geom = \"point\", curve.x.axis = \"terms\", colour = \"blue\"\r\n      )\r\n    print(g)\r\n  },\r\n  interval = 0.8,\r\n  ani.height = 400,\r\n  ani.width = 704\r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-17-movimento-da-parte-longa-da-curva-de-juros/animation.gif",
    "last_modified": "2022-08-17T07:25:40-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-06-24-super-datasets-para-opcoes-de-acoes/",
    "title": "Super Datasets para Opções de Ações",
    "description": "Um dos super datasets do pacote {rb3} é o de opções de ações.\nCom este dataset é possível realizar diversos cálculos com dados de opções de ações, como\ncalcular a volatilidade implícita das opções, as gregas e até mesmo fazer o ajuste de\nmodelos teóricos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-24",
    "categories": [],
    "contents": "\r\nDados de opções de ações finalmente disponíveis de forma simples e direta. Durante muito tempo busquei isso, os dados de opções são mais chatos pois precisam de outros dados para a realização dos cálculos. Ter apenas os dados de prêmio das opções (preços das opções) não permite que diversas das medidas de interesse associadas a opções, como as gregas e a volatilidade implícita, sejam calculadas. Utilizando Black & Scholes é necessário ainda ter o preço do ativo objeto (preço da ação) e as taxas de juros. Com estas informações é possível calcular a volatilidade e a partir daí todas as demais medidas de interesse podem ser calculadas.\r\nVou mostrar aqui como calcular a volatilidade e as gregas para opções a partir de dados obtidos com o pacote {rb3}. Para realizar os cálculos com as opções eu utilizo o pacote {oplib} que desenvolvi com diversos modelos implementados:\r\nBlack, Scholes & Merto para apreçamento das opções\r\nBlack para apreçamento de opções sobre futuros, utilizado em opções sobre índices de taxas de juros, como IDI\r\nCorrado-Su para o apreçamento de opções considerando assimetria e curtose\r\nentre outros\r\nEste pacote ainda é experimental, não está publicado no CRAN e a documentação ainda está em desenvolvimento.\r\nVamos começar carregando os pacotes\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(tidyverse)\r\nlibrary(oplib)\r\n\r\n\r\nVamos selecionar o último dia útil para obter os dados diários do arquivo COTAHIST disponibilizado pela B3. O arquivo COTAHIST traz diversas informações do mercado de ações e inclui as opções. Adicionalmente, precisamos das taxas de juros e utilizo a função rb3::yc_get para obter a curva de juros para a data de referência.\r\n\r\n\r\nrefdate <- preceding(\"2022-06-24\", \"Brazil/ANBIMA\")\r\nch <- cotahist_get(refdate, \"daily\")\r\nyc <- yc_get(refdate)\r\n\r\n\r\nCom os dados de ações e opções, pelo arquivo COTAHIST, e com as taxas de juros, utilizo a função rb3::cotahist_options_by_symbol_superset para obter os dados de opções para um símbolo específico. Aqui vou utilizar PETR4 que é uma das ações com maior volume de negociação na bolsa.\r\n\r\n\r\nsymbol_ <- \"PETR4\"\r\nop1 <- cotahist_options_by_symbol_superset(symbol_, ch, yc)\r\n\r\n\r\nNo data.frame op1 temos informações de preço da ação na data de referência, preços das opções, taxas de juros, vencimento das opções, volumes de negociação e diversas outras informações.\r\n\r\n\r\nop1\r\n\r\n# A tibble: 437 x 28\r\n   refdate    symbol   type  strike maturity~1  open  high   low close\r\n   <date>     <chr>    <fct>  <dbl> <date>     <dbl> <dbl> <dbl> <dbl>\r\n 1 2022-06-24 PETRA140 Call    1.94 2023-01-20 24.8  24.8  24.8  24.8 \r\n 2 2022-06-24 PETRA239 Call   50.4  2023-01-20  0.09  0.24  0.09  0.23\r\n 3 2022-06-24 PETRA281 Call   18.4  2023-01-20  9.6   9.6   9.6   9.6 \r\n 4 2022-06-24 PETRA297 Call   30.2  2023-01-20  2.7   2.7   2.7   2.7 \r\n 5 2022-06-24 PETRA359 Call   29.4  2023-01-20  2.87  2.87  2.87  2.87\r\n 6 2022-06-24 PETRA361 Call   26.4  2023-01-20  4.3   4.3   4.23  4.23\r\n 7 2022-06-24 PETRD450 Call   38.4  2023-04-20  1.42  1.42  1.42  1.42\r\n 8 2022-06-24 PETRG1   Call   13.4  2022-07-15 13.7  13.7  12.6  12.6 \r\n 9 2022-06-24 PETRG121 Call   19.2  2022-07-15  7.87  7.87  7.36  7.37\r\n10 2022-06-24 PETRG178 Call   20.2  2022-07-15  6.7   6.7   6.45  6.45\r\n# ... with 427 more rows, 19 more variables: average <dbl>,\r\n#   volume <dbl>, traded_contracts <dbl>,\r\n#   transactions_quantity <int>, distribution_id <int>,\r\n#   symbol.underlying <chr>, open.underlying <dbl>,\r\n#   high.underlying <dbl>, low.underlying <dbl>,\r\n#   close.underlying <dbl>, average.underlying <dbl>, best_bid <dbl>,\r\n#   best_ask <dbl>, volume.underlying <dbl>, ...\r\n\r\npara simplificar os cálculos vou separar duas informações úteis, os vencimentos das opções e o preço de fechamento da ação, que é único para a data de referência. Os vencimentos das opções são ordenados para que eu possa facilmente selecionar um vencimento desejado.\r\n\r\n\r\nmaturities <- unique(op1$maturity_date) |> sort()\r\nclose_underlying <- op1$close.underlying[1]\r\n\r\n\r\nAs opções de ações, tipicamente, possuem maior liquidez no primeiro vencimento disponível. Por isso, vou selecionar todas as opções com maturity_date == maturities[1].\r\n\r\n\r\nop_vol <- op1 |>\r\n  filter(maturity_date == maturities[1]) |>\r\n  mutate(\r\n    biz_days = bizdays(\r\n      refdate, following(maturity_date, \"Brazil/ANBIMA\"), \"Brazil/ANBIMA\"\r\n    ),\r\n    time_to_maturity = biz_days / 252,\r\n    rate = log(1 + r_252),\r\n    impvol = bsmimpvol(\r\n      close, type, close.underlying, strike, time_to_maturity, rate, 0\r\n    ),\r\n    delta = bsmdelta(\r\n      type, close.underlying, strike, time_to_maturity, rate, 0, impvol\r\n    )\r\n  ) |>\r\n  select(\r\n    symbol, volume,\r\n    type, close.underlying, strike, time_to_maturity, rate, impvol,\r\n    delta, biz_days, volume\r\n  )\r\n\r\n\r\nApós a seleção das opções, uma série de cálculos são realizados para obter:\r\ndias úteis até o vencimento biz_days\r\nprazo em anos até o vencimento time_to_maturity\r\ntaxas de juros em capitalização contínua rate\r\nvolatilidade implícita impvol com o modelo Black & Scholes\r\na grega delta para o modelo Black & Scholes\r\nEm seguida algumas variáveis são selecionadas para a visualizção dos dados.\r\nVamos visualizar o smile de volatilidade para com os preços de exercício das opções no eixo X Coloco uma linha vertical marcando o nível do preço do ativo objeto, facilitando a interpretação do que está dentro/fora do dinheiro para as opções de compra e venda (Calls e Puts). O tamanho de cada ponto é definido pelo volumen de negociação de cada opção. Interessante notar que os maiores volumes ficam nos strikes próximos do preço atual do ativo objeto. Estas são as opções ATM, no dinheiro.\r\n\r\n\r\nop_vol |>\r\n  filter(!is.na(impvol)) |>\r\n  ggplot(aes(x = strike, y = impvol, colour = type, size = volume)) +\r\n  geom_point() +\r\n  geom_vline(xintercept = close_underlying, alpha = 0.5, size = 1) +\r\n  facet_wrap(type ~ biz_days) +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = \"Strike\", y = \"Implied Volatility\",\r\n    title = str_glue(\"Equity Options Volatility - {symbol_} {format(refdate)}\")\r\n  )\r\n\r\n\r\n\r\nAbaixo temos o smile de volatilidade com o delta das opções no eixo X. Aqui fica mais fácil visualizar as opções ATM, pois estas tem delta de 0.5 (ou -0.5 no caso das Puts).\r\n\r\n\r\nop_vol |>\r\n  filter(!is.na(impvol)) |>\r\n  ggplot(aes(x = delta, y = impvol, colour = type, size = volume)) +\r\n  geom_point() +\r\n  geom_vline(xintercept = c(-0.5, 0.5), alpha = 0.5, size = 1) +\r\n  facet_wrap(~ biz_days, scales = \"free\") +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = \"Delta\", y = \"Implied Volatility\",\r\n    title = str_glue(\"Equity Options Volatility - {symbol_} {format(refdate)}\")\r\n  )\r\n\r\n\r\n\r\nO objetivo deste post é mostrar como é fácil obter dados de opções com o pacote {rb3} e com o pacote {oplib} realizar os cálculos com estes dados.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-24-super-datasets-para-opcoes-de-acoes/super-datasets-para-opcoes-de-acoes_files/figure-html5/strike-vol-1.png",
    "last_modified": "2022-08-22T07:18:37-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-19-super-datasets-do-pacote-rb3/",
    "title": "Super Datasets do Pacote rb3",
    "description": "O pacote {rb3} traz funções que retornam *super datasets*, conjuntos de dados mais ricos juntando\na informação de diferentes datasets obtidos com as funções do pacote.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-19",
    "categories": [],
    "contents": "\r\nA versão 0.0.3 do pacote {rb3} trouxe funções que retornam super datasets. Estes super datasets são dataframes com dados organizados para um fim específico. Por exemplo, a função rb3::yc_get retorna um dataframe com dados da curva de juros para diversos vértices, dentre os vértices retornados alguns são referentes aos vencimentos dos contratos futuros utilizados para produzir a curva original. Para alguns problemas é interessante conhecer quais vértices são referentes aos futuros, por exemplo, na criação de fatores primitivos de risco, onde a interpolação deve ser realizada utilizando apenas os futuros. Os contratos futuros podem ser obtidos com a função rb3::futures_get. Dessa maneira, a função rb3::yc_superset junta os dados retornados pelas funções rb3::yc_get e rb3::futures_get identificando os vencimentos dos contratos futuros na curva de juros. Por isso super dataset, é um dataset mais rico!\r\nAtualmente o pacote apresenta as seguintes funções superset:\r\nrb3::yc_superset retorna a curva de juros de prefixados com os contratos fututos DI1 identificados.\r\nrb3::yc_usd_superset retorna a curva de cupom cambial com os contratos fututos DOL identificados.\r\nrb3::yc_ipca_superset retorna a curva de juros reais com os contratos fututos DAP identificados.\r\nrb3::cotahist_equity_options_superset retorna dados de opções de ações com informações de ações e taxas de juros.\r\nVou exemplificar a utilização de um super dataset com a função rb3::yc_superset. Vou criar uma curva de juros apenas com os contratos futuros de DI1. Mas antes vou responder uma pergunta que talvez tenha chegado a cabeça dos leitores: Por que criar uma curva de juros apenas com os contratos futuros se já tenho uma curva de juros cheia de vértices? Primeiramente, toda curva de juros nasce a partir de um conjunto de contratos, no caso da curva prefixada utiliza-se os contratos futuros DI1, mais a taxa DI no vértice de 1 dia útil, assim, estaria retornando a curva ao seu estado original. Logo, todos os demais vértices da curva são obtidos a partir da interpolação entre os contratos futuros. Adicionalmente, caso eu precise de um vértice que não está na curva será necessário interpolar e como interpolar se não conheço os vértices referentes aos futuros? Bem, posso interpolar nos vértices presentes, mas assim estaria interpolando sobre vértices interpolados. Não é um grande problema fazer isso, mas isso pode trazer problemas na contrução de fatores de risco para taxa de juros, por exemplo.\r\nDando sequência, primeiro utilizamos o {rb3} para obter os dados dos futuros e da curva para a data de referência.\r\n\r\n\r\nlibrary(rb3)\r\n\r\nrefdate <- \"2022-06-17\"\r\n\r\nfut <- futures_get(refdate)\r\nyc <- yc_get(refdate)\r\n\r\n\r\nDepois passo estes dados para a função yc_superset que junta os dados para indentificar os contratos futuros.\r\n\r\n\r\ndf <- yc_superset(yc, fut)\r\ndf |> head()\r\n\r\n# A tibble: 6 x 7\r\n  refdate    cur_days biz_days forward_date r_252 r_360 symbol\r\n  <date>        <int>    <dbl> <date>       <dbl> <dbl> <chr> \r\n1 2022-06-17        3        1 2022-06-20   0.132 0     <NA>  \r\n2 2022-06-17        7        5 2022-06-24   0.132 0.134 <NA>  \r\n3 2022-06-17       12        8 2022-06-29   0.132 0.125 <NA>  \r\n4 2022-06-17       13        9 2022-06-30   0.132 0.13  <NA>  \r\n5 2022-06-17       14       10 2022-07-01   0.132 0.134 DI1N22\r\n6 2022-06-17       21       15 2022-07-08   0.132 0.134 <NA>  \r\n\r\nTendo o super dataset eu filtro as linhas referentes aos futuros e a linha referente a 1 dia útil.\r\n\r\n\r\nlibrary(dplyr)\r\n\r\ndf_curve <- bind_rows(\r\n  df |> filter(biz_days == 1) |> select(biz_days, r_252),\r\n  df |> filter(!is.na(symbol)) |> select(biz_days, r_252)\r\n)\r\n\r\ndf_curve |> head()\r\n\r\n# A tibble: 6 x 2\r\n  biz_days r_252\r\n     <dbl> <dbl>\r\n1        1 0.132\r\n2       10 0.132\r\n3       31 0.132\r\n4       54 0.133\r\n5       75 0.134\r\n6       95 0.134\r\n\r\nPronto! Tenho a curva original novamente.\r\nApenas para ilustrar, vamos utilizar o pacote {fixedincome} para construir um objeto de curva de juros e visualizar os dados.\r\n\r\n\r\nlibrary(fixedincome)\r\n\r\ncurve <- spotratecurve(\r\n  df_curve$r_252, df_curve$biz_days, \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n  refdate = as.Date(refdate)\r\n)\r\n\r\n\r\nVisualizando a curva.\r\n\r\n\r\nggspotratecurveplot(curve)\r\n\r\n\r\n\r\nVisualizando para um horizonte mais curto e adicionando as taxas a termo.\r\n\r\n\r\ncurve_2y <- curve |> fixedincome::first(\"2 years\")\r\nggspotratecurveplot(curve_2y) +\r\n  ggplot2::autolayer(forwardrate(curve_2y))\r\n\r\n\r\n\r\nBem, os super datasets estão aí para ajudar! Entregam dados da B3 mais mastigados para as necessidades dos quants do mercado brasileiro.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-19-super-datasets-do-pacote-rb3/super-datasets-do-pacote-rb3_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2022-08-18T07:50:26-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-18-16-anos-de-curva-prefixada/",
    "title": "16 anos de Curva Prefixada",
    "description": "Observando a dinâmica da estrutura a termo de juros no Brasil e nos Estados\nUnidos ao longo dos últimos 16 anos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-18",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(dplyr)\r\nlibrary(fixedincome)\r\nlibrary(ggplot2)\r\n\r\n\r\n\r\n\r\n\r\n\r\nO pacote {rb3} faz extrações de dados do site da B3. Temos diversas informações disponíveis no site inclusive o histórico de diversos dados.\r\nUm conjunto de dados que mais utilizo são os preços de ajuste dos contratos futuros. Este histórico é um dos mais antigos disponível.\r\nVou baixar todo o histórico de contratos futuros desde 2007. A partir dos preços de ajuste é possível construir o histórico de curvas prefixadas. Depois vou fazer uma segmentação pelo ano da data de referência para que seja possível visualizar, para cada ano, todo o espectro de curvas no ano.\r\nVou começar baixando todos os dados desde 2007 até a última data disponível. Para isso vou utilizar a função rb3::futures_mget. Isso leva um bom tempo!\r\n\r\n\r\ndf <- futures_mget(\r\n  first_date = \"2007-01-01\",\r\n  last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\")\r\n)\r\n\r\n\r\n\r\nÉ necessário filtrar os contratos futuros de DI1 para construir a curva prefixada.\r\n\r\n\r\ndf_di1 <- df |> filter(commodity == \"DI1\")\r\n\r\n\r\n\r\nPara construir a curva prefixada é necessário obter as datas de vencimento dos contratos futuros. Para isso utilizo a função rb3::maturity2date que converte o código de vencimento em data. Adicionalmente faço o ajuste da data de referência criando a coluna fixing, calculo os dias úteis (coluna business_days) e a taxa de juros com base no preço de ajuste price gerando a coluna adjusted_tax.\r\n\r\n\r\ndf_di1_futures <- df_di1 |>\r\n  mutate(\r\n    maturity_date = maturity2date(maturity_code),\r\n    fixing = following(maturity_date, \"Brazil/ANBIMA\"),\r\n    business_days = bizdays(refdate, fixing, \"Brazil/ANBIMA\"),\r\n    adjusted_tax = implied_rate(\"discrete\", business_days / 252, 100000 / price)\r\n  ) |>\r\n  filter(business_days > 0)\r\n\r\n\r\n\r\nTermino filtrando as linhas com business_days maior que zero, pois não me interessam os futuros na data de vencimento.\r\nAgora vamos gerar a visualização com ggplot2.\r\n\r\n\r\ndf_di1_futures |>\r\n  mutate(year = as.integer(format(refdate, \"%Y\"))) |>\r\n  ggplot(aes(\r\n    x = business_days, y = adjusted_tax,\r\n    group = refdate\r\n  )) +\r\n  geom_line(alpha = 0.2) +\r\n  facet_wrap(. ~ year) +\r\n  labs(\r\n    x = \"Dias Úteis\", y = \"Taxas\",\r\n    title = \"16 anos de Curva Prefixada\",\r\n    subtitle = \"Curvas construídas a partir dos preços de ajuste dos contratos Futuros DI1\",\r\n    caption = \"Fonte: B3 (obtidos com \\U1F4E6 rb3) - wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nCurioso ver a mudança de shape da curva entre os anos e ao longo de cada ano. Uma coisa curiosa é observar os anos de 2016, 2017 e 2018. 2016/2017 foram os anos do impechemant da presidente Dilma. Em 2016 a parte curta da curva variou pouco e a parte longa variou muito. Em 2017 aconteceu o oposto, a parte curta da curva variou mais que a parte longa da curva. Nestes anos, as mudanças afetam diretamente o shape da curva. Em 2018, o ano da eleição e da facada do Bolsonaro, há uma grande variação na parte longa da curva, mas sem alterar o shape da curva. Ainda é possível avaliar o comportamento da curva com os demais eventos políticos e econômicos. Em 2021, por exemplo, onde ocorreu uma elevação da taxa SELIC e uma piora do cenário fiscal, temos um espectro muita amplo do shape da curva.\r\nÉ possível construir uma visualização equivalente utilizando dados da curva americana que podem ser obtidos com o pacote Quandl.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nOs dados vem no formato wide onde cada coluna representa um vértice e cada linha uma curva. Dessa maneira, faço a conversão dos dados para o formato longo com a função tidyr::pivot_longer.\r\n\r\n\r\nyc_all <- as_tibble(yc_all)\r\n\r\nyc_all_longer <- yc_all |>\r\n  tidyr::pivot_longer(cols = `1 MO`:`30 YR`)\r\n\r\nyc_all_longer\r\n\r\n\r\n# A tibble: 96,384 x 3\r\n   Date       name  value\r\n   <date>     <chr> <dbl>\r\n 1 2022-02-04 1 MO   0.05\r\n 2 2022-02-04 2 MO   0.12\r\n 3 2022-02-04 3 MO   0.23\r\n 4 2022-02-04 6 MO   0.56\r\n 5 2022-02-04 1 YR   0.89\r\n 6 2022-02-04 2 YR   1.31\r\n 7 2022-02-04 3 YR   1.55\r\n 8 2022-02-04 5 YR   1.78\r\n 9 2022-02-04 7 YR   1.9 \r\n10 2022-02-04 10 YR  1.93\r\n# ... with 96,374 more rows\r\n\r\nAqui faço o tratamento dos dados para converter os prazos em números, considerando meses de 30 dias e anos de 360 dias.\r\n\r\n\r\nlibrary(stringr)\r\n\r\nn <- str_match(yc_all_longer$name, \"\\\\d+\") |> as.numeric()\r\np <- str_match(yc_all_longer$name, \"(MO|YR)$\")[, 1]\r\nyc_all_longer$days <- ifelse(p == \"MO\", 30, 360) * n\r\n\r\nyc_all_longer\r\n\r\n\r\n# A tibble: 96,384 x 4\r\n   Date       name  value  days\r\n   <date>     <chr> <dbl> <dbl>\r\n 1 2022-02-04 1 MO   0.05    30\r\n 2 2022-02-04 2 MO   0.12    60\r\n 3 2022-02-04 3 MO   0.23    90\r\n 4 2022-02-04 6 MO   0.56   180\r\n 5 2022-02-04 1 YR   0.89   360\r\n 6 2022-02-04 2 YR   1.31   720\r\n 7 2022-02-04 3 YR   1.55  1080\r\n 8 2022-02-04 5 YR   1.78  1800\r\n 9 2022-02-04 7 YR   1.9   2520\r\n10 2022-02-04 10 YR  1.93  3600\r\n# ... with 96,374 more rows\r\n\r\nAgora fazemos a visualização.\r\n\r\n\r\nyc_all_longer |>\r\n  mutate(\r\n    year = as.integer(format(Date, \"%Y\")),\r\n    value = value / 100\r\n  ) |>\r\n  filter(year >= 2007) |>\r\n  ggplot(aes(\r\n    x = days, y = value,\r\n    group = Date\r\n  )) +\r\n  geom_line(alpha = 0.2) +\r\n  facet_wrap(. ~ year) +\r\n  labs(\r\n    x = \"Dias Corridos\", y = \"Taxas\",\r\n    title = \"16 anos de Curva Prefixada Americana\",\r\n    caption = \"Fonte: US Treasury (obtidos com \\U1F4E6 Quandl) - wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nJá na curva americana, a dinâmica é muito mais bem comportada. A parte longo costuma oscilar, mas mantendo a dinâmica. Os anos 2007, 2008 e 2020, onde tivemos crise do subprime e COVID, trouxeram mais volatilidade.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-18-16-anos-de-curva-prefixada/16-anos-de-curva-prefixada_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-07-18T20:18:38-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1536
  },
  {
    "path": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/",
    "title": "Histórico de Taxas de Juros em Dólar no Brasil",
    "description": "Foi analisado em um post recente a dinâmica das taxas de juros,\nbrasileira e americana.\nTrago neste post a comparação entre as taxas de juros em dólar,\nno Brasil e nos Estados Unidos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-10",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nEm um post recente.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndusd <- yc_usd_mget(\r\n  first_date = \"2019-01-01\",\r\n  last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n  cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\n\r\n\r\nunique(dusd$refdate) |> map(function(date, df) {\r\n  df_curve <- df |>\r\n    filter(refdate == date, cur_days > 0) |>\r\n    filter(!duplicated(cur_days))\r\n  curve <- spotratecurve(\r\n    df_curve$r_360,\r\n    df_curve$cur_days,\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = date\r\n  )\r\n  interpolation(curve) <- interp_flatforward()\r\n  curve\r\n}, df = dusd) -> curves_usd\r\n\r\n\r\n\r\n\r\n\r\ncurves_usd |>\r\n  map_dfr(\\(x) tibble(\r\n    refdate = x@refdate,\r\n    r_USD_br_10y = as.numeric(x[[3600]])\r\n  )) -> rates_usd_10y\r\n\r\n\r\n\r\n\r\n\r\nrates_10y |>\r\n  left_join(rates_usd_10y, by = \"refdate\") |>\r\n  tidyr::pivot_longer(c(r_USD_br_10y, r_USD_us_10y),\r\n    names_to = \"rates\"\r\n  ) |>\r\n  ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n  geom_line() +\r\n  labs(colour = NULL) +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = NULL, y = NULL,\r\n    title = \"Histórico de Taxas de Juros em Dólar de 10 Anos\",\r\n    subtitle = \"Estados Unidos (r_USD_us_10y) e Brasil (r_USD_br_10y)\",\r\n    caption = \"wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent) +\r\n  theme(legend.position = \"bottom\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/histrico-de-taxas-de-juros-em-dlar-no-brasil_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-06-11T06:00:32-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/",
    "title": "Histórico de Taxas de Juros de Longo Prazo",
    "description": "As taxas de juros de longo prazo são importantes variáveis econômicas.\nObservar a dinâmica dessas taxas é fundamental para uma boa compreensão\ndo cenário econômico.\nVamos ver como utilizar o pacote {fixedincome} para construir o histórico da\ntaxa de juros prefixada para o prazo de 10 anos com dados extraídos da B3\ncom o pacote {rb3}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-09",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nNo mercado norte americano há cotações para taxas de juros em prazos fixos, 1 ano, 5 anos, 10 anos, e assim por diante. Estas estruturas são conhecidas como Constant Term Maturities.\r\nEstes dados podem ser obtidos do site do Tesouro Americano (US Treasury) com o pacote {Quandl}.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nPodemos observar um longo histórico, desde a década de 90, para estas taxas.\r\n\r\n\r\nyc_all |>\r\n    ggplot(aes(x = Date, y = `10 YR` / 100)) +\r\n    geom_line() +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Histórico de Taxas de Juros Americanos de 10 Anos (Treasury Bonds)\",\r\n        caption = \"Dados do US Treasury obtidos com o pacote Quandl - wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nNo mercado brasileiro, infelizmente, a vida é um pouco miserável, e não há um histórico disponível com taxas de longo prazo. É necessário construir na unha e na força do ódio.\r\nOs ativos líquidos de onde são extraídas as taxas de juros de longo prazo são os contratos futuros de taxa DI - DI1, que são cotados diariamente na B3 em seus vencimentos. Entretanto, as taxas de juros obtidas destes contratos apresentam um prazo diferente a cada dia. Assim, é necessário construir uma curva de juros com estes contratos e realizar uma interpolação nos prazos fixos, 1 ano, 5 anos, 10 anos, e por aí vai.\r\nVamos utilizar o pacote {rb3} para obter o histórico com as curvas diárias de juros prefixados do mercado brasileiro e o pacote {fixedincome} para construir os objetos de curvas de juros e realizar a interpolação das curvas nos vértices fixos para obter o histórico de taxas de juros de longo prazo.\r\nVamos começar importando os pacotes utilizados nessa jornada.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(fixedincome)\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\nA função rb3::yc_mget retorna um data.frame com o histórico de curvas de juros. Vamos baixar um histórico desde 2019.\r\n\r\n\r\ndc <- yc_mget(\r\n    first_date = \"2019-01-01\",\r\n    last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n    cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\nDe posse do histórico, vamos construir as curvas de juros para cada data de referência utilizando a função fixedincome::spotratecurve. A curva de juros prefixada tem as seguintes características:\r\nregime de capitalização: discrete (juros compostos)\r\nregra de contagem de dias: business/252\r\ncalendário: Brazil/ANBIMA\r\ninterpolação: flat-forward\r\nAdicionalmente faço uma limpeza nos eventuais problemas encontrados nos dados, como dias úteis zerados e duplicados. Bem, é de graça, exigir dados corretos deve ser um pouco demais, né?\r\n\r\n\r\nunique(dc$refdate) |> map(function(date, df) {\r\n    df_curve <- df |>\r\n        filter(refdate == date, biz_days > 0) |>\r\n        filter(!duplicated(biz_days))\r\n    curve <- spotratecurve(\r\n        df_curve$r_252,\r\n        df_curve$biz_days,\r\n        \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n        refdate = date\r\n    )\r\n    interpolation(curve) <- interp_flatforward()\r\n    curve\r\n}, df = dc) -> curves\r\n\r\n\r\n\r\nObtendo um lista com as curvas de juros utilizamos os colchetes [[ para realizar a interpolação no prazo fixo de 10 anos. Como estas curvas utilizam a regra de contagem de dias business/252, devemos considerar que 1 ano tem 252 dias úteis e portanto, 10 anos tem 2520 dias úteis. Por isso, interpolamos a curva no vértice 2520.\r\n\r\n\r\ncurves |>\r\n    map_dfr(\\(x) tibble(\r\n        refdate = x@refdate,\r\n        r_BRL_10y = as.numeric(x[[2520]])\r\n    )) -> rates_10y\r\n\r\n\r\n\r\nJá aproveito e retorno o histórico em um data.frame com as colunas refdate e r_BRL_10y. Faço isso para juntar com os dados de juros americanos de 10 anos e assim comparar a dinâmica das taxas conjuntamente.\r\n\r\n\r\nrates_10y <- rates_10y |>\r\n    left_join(yc_all |> select(Date, `10 YR`), by = c(\"refdate\" = \"Date\")) |>\r\n    rename(r_USD_us_10y = `10 YR`) |>\r\n    mutate(r_USD_us_10y = r_USD_us_10y / 100)\r\n\r\n\r\n\r\nNote que eu nomeio a taxa de juros americana com r_USD_us_10y, pois essa é uma taxa que capitaliza o dólar (USD) nos Estados Unidos (us). Abaixo faço um malabarismo com tidyr::pivot_longer para preparar os dados para o ggplot e assim visualizá-los lado a lado. Note ainda que libero a escala dos gráficos (scales = \"free_y\") para que a diferença de nível entre as taxas de juros, brasileira e americana, não afete a análise. O objetivo é visualizar a dinâmica das taxas de juros ao longo do tempo.\r\n\r\n\r\nrates_10y |>\r\n    tidyr::pivot_longer(\r\n        c(r_BRL_10y, r_USD_us_10y),\r\n        names_to = \"rates\"\r\n    ) |>\r\n    ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n    geom_line() +\r\n    facet_wrap(. ~ rates, scales = \"free_y\") +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Histórico de Taxas de Juros de 10 Anos\",\r\n        subtitle = \"Americanos (r_USD_us_10y) e Brasileiro (r_BRL_10y)\",\r\n        caption = \"wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent) +\r\n    theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/histrico-de-taxas-de-juros-de-longo-prazo_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-06-10T08:32:29-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/",
    "title": "Curva de Juros de Americana - US Treasuries Curve",
    "description": "Como construir a curva de juros americana utilizando dados do Tesouro\nAmericano (US Treasury) e o pacote {fixedincome}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-06",
    "categories": [
      "R",
      "fixedincome",
      "opendata"
    ],
    "contents": "\r\nA curva de juros americana é uma peça fundamental do quebra-cabeças econômico/financeiro. Neste post vamos ver como obter os dados do histórico da estrutura a termo de juros dos Estados Unidos e como construir uma curva de juros utilizando o pacote {fixedincome}.\r\nVamos utilizar o Quandl, que hoje é o Nasdaq Data Link, para obter o histórico de juros americanos.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nyc_all traz todo o histórico de juros, as Constant Maturity Treasury rates, que relacionam as taxas de juros ao um conjuto de prazos padronizados: 1, 3, e 6 meses, e 1, 2, 3, 5, 7, 10, 20, e 30 anos.\r\n\r\n\r\nhead(yc_all)\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78 1.90  1.93  2.29\r\n2 2022-02-03 0.03 0.15 0.20 0.48 0.78 1.19 1.42 1.66 1.78  1.82  2.20\r\n3 2022-02-02 0.04 0.10 0.19 0.45 0.76 1.16 1.38 1.60 1.74  1.78  2.17\r\n4 2022-02-01 0.04 0.10 0.19 0.48 0.78 1.18 1.39 1.63 1.76  1.81  2.19\r\n5 2022-01-31 0.03 0.13 0.22 0.49 0.78 1.18 1.39 1.62 1.75  1.79  2.17\r\n6 2022-01-28 0.04 0.10 0.19 0.43 0.75 1.15 1.38 1.61 1.74  1.78  2.14\r\n  30 YR\r\n1  2.23\r\n2  2.14\r\n3  2.11\r\n4  2.12\r\n5  2.11\r\n6  2.07\r\n\r\nVamos montar a curva de juros para uma data específica utilizando os prazos definidos no histórico.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nrefdate <- as.Date(\"2022-02-04\")\r\nyc <- yc_all |> filter(Date == refdate)\r\n\r\nyc\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78  1.9  1.93  2.29\r\n  30 YR\r\n1  2.23\r\n\r\nComecemos construindo o vetor de prazos da curva. Para isso precisamos interpretar os nomes das colunas e convertê-los em prazos.\r\n\r\n\r\nnx <- names(yc)\r\nterms_names <- nx[-1]\r\nterms_names\r\n\r\n\r\n [1] \"1 MO\"  \"2 MO\"  \"3 MO\"  \"6 MO\"  \"1 YR\"  \"2 YR\"  \"3 YR\"  \"5 YR\" \r\n [9] \"7 YR\"  \"10 YR\" \"20 YR\" \"30 YR\"\r\n\r\nTemos MO indicando prazos em meses e YR indicando os anos. Vamos utilizar uma simples substituição de texto para converter MO para months e YR para years. Dessa forma podemos utilizar a função fixedincome::as.term que converte um string em um objeto term (prazo).\r\n\r\n\r\nlibrary(stringr)\r\n\r\nterms_names <- terms_names |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\")\r\n\r\nterms_names\r\n\r\n\r\n [1] \"1 months\" \"2 months\" \"3 months\" \"6 months\" \"1 years\"  \"2 years\" \r\n [7] \"3 years\"  \"5 years\"  \"7 years\"  \"10 years\" \"20 years\" \"30 years\"\r\n\r\nApós a conversão usamos a função purrr::map com a função fixedincome::as.term e assim vamos obter uma lista com diversos objetos term.\r\n\r\n\r\nlibrary(purrr)\r\nlibrary(fixedincome)\r\n\r\ncurve_terms <- map(terms_names, as.term)\r\ncurve_terms\r\n\r\n\r\n[[1]]\r\n[1] \"1 month\"\r\n\r\n[[2]]\r\n[1] \"2 months\"\r\n\r\n[[3]]\r\n[1] \"3 months\"\r\n\r\n[[4]]\r\n[1] \"6 months\"\r\n\r\n[[5]]\r\n[1] \"1 year\"\r\n\r\n[[6]]\r\n[1] \"2 years\"\r\n\r\n[[7]]\r\n[1] \"3 years\"\r\n\r\n[[8]]\r\n[1] \"5 years\"\r\n\r\n[[9]]\r\n[1] \"7 years\"\r\n\r\n[[10]]\r\n[1] \"10 years\"\r\n\r\n[[11]]\r\n[1] \"20 years\"\r\n\r\n[[12]]\r\n[1] \"30 years\"\r\n\r\nObviamente tudo isso poderia ter sido feito de forma direta.\r\n\r\n\r\ncurve_terms <- nx[-1] |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\") |>\r\n  map(as.term)\r\n\r\n\r\n\r\nPois bem, temos uma lista com prazos em meses e prazos em anos. É necessário converter os prazos para uma mesma unidade (units). Vou converter todos os prazos para dias. Para fazer isso vou criar um objeto daycount(\"actual/360\"), que é a regra de contagem de dias que considera dias corridos e anos com 360 dias. Com a regra de contagem de dias conseguimos fazer a conversão dos prazos para anos e utilizando a quantidade de dias no ano da regra, 360, fazemos a conversão para dias.\r\n\r\n\r\ndc <- daycount(\"actual/360\")\r\n\r\nterms <- curve_terms |>\r\n    map_dbl(\\(x) dib(dc) * toyears(dc, x)) |>\r\n    term(\"days\")\r\n\r\nterms\r\n\r\n\r\n [1] \"30 days\"    \"60 days\"    \"90 days\"    \"180 days\"   \"360 days\"  \r\n [6] \"720 days\"   \"1080 days\"  \"1800 days\"  \"2520 days\"  \"3600 days\" \r\n[11] \"7200 days\"  \"10800 days\"\r\n\r\nA função fixedincome::toyears converte os prazos para um número em anos, por exemplo, 6 meses retorna 0.5, e a função dib retorna a quantidade de dias no ano para a regra, neste caso, 360. Concluímos criando os objetos de prazo com term.\r\nAgora que já temos os prazos da curva vamos extrair as taxas do data.frame. É uma operação simples de extração de linhas de um data.frame e converter em um vetor. Fazemos uma verificação de NA por que eventualmente há podemos ter valores ausentes para alguns prazos.\r\n\r\n\r\nrates <- yc[1, -1] |>\r\n    as.list() |>\r\n    as.numeric()\r\nrates <- rates / 100\r\nix <- !is.na(rates)\r\n\r\nrates[ix]\r\n\r\n\r\n [1] 0.0005 0.0012 0.0023 0.0056 0.0089 0.0131 0.0155 0.0178 0.0190\r\n[10] 0.0193 0.0229 0.0223\r\n\r\nTendo os prazos, as taxas e a data de referência, podemos construir a curva com a função fixedincome::spotratecurve. Para a curva de juros americana utilizamos taxa de juros simples (compounding simple), regra de contagem de dias (actual/360) e o calendário de dias corridos (actual).\r\n\r\n\r\ntr_curve <- spotratecurve(\r\n    rates[ix], terms[ix],\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = refdate\r\n)\r\n\r\ntr_curve\r\n\r\n\r\n          SpotRateCurve\r\n30 days          0.0005\r\n60 days          0.0012\r\n90 days          0.0023\r\n180 days         0.0056\r\n360 days         0.0089\r\n720 days         0.0131\r\n1080 days        0.0155\r\n1800 days        0.0178\r\n2520 days        0.0190\r\n3600 days        0.0193\r\n# ... with 2 more rows\r\nsimple actual/360 actual \r\nReference date: 2022-02-04 \r\n\r\nNote os prazos em dias. Agora é só visualizar a curva de forma graciosa!\r\n\r\n\r\nplot(tr_curve)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/curva-de-juros-de-americana-us-treasuries-curve_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2022-06-08T06:41:20-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-05-indicadores-da-pesquisa-focus/",
    "title": "Indicadores da Pesquisa Focus",
    "description": "As APIs de Expectativas de Mercado da Pesquisa Focus não informam\ndireito quais indicadores estão disponíveis. A documentação é meio falha e\npouco confiável. Dessa maneira, a única maneira de descobrir o que está\ndisponível é investigando a API. É isso que vou mostrar como fazer neste post.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-05",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFunção get_market_expectations\r\nDescobrindo indicadores disponíveis\r\nannual\r\nmonthly\r\nquarterly\r\ninflation-12-months\r\ntop5s-annual\r\ntop5s-monthly\r\ntop5s-selic\r\nselic\r\ninstitutions\r\n\r\nConclusão\r\n\r\nÉ possível obter as expectativas de mercado para diversos indicadores macroeconômicos da pesquisa Focus de forma totalmente automática utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} é uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroeconômicos da pesquisa Focus são consolidadas em estatísticas diárias e divulgadas na API. Estas estatísticas são calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais instituições do mercado financeiro. Os indicadores macroeconômicos são referentes a índices de preços, crescimento do PIB e da produção industrial, taxa de câmbio, taxa Selic, variáveis fiscais e indicadores do setor externo e são publicadas todo primeiro dia útil da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFunção get_market_expectations\r\nA função get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se não for informado o valor annual será utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroeconômicos\r\ninflation-12-months para expectativas de inflação nos próximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas instituições credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroeconômico, é opcional, de forma, quando não for definido, todos os indicadores disponíveis para o endpoint serão retornados. Esse ponto é curioso, pois a documentação não é boa e informa indicadores que não são mais disponibilizados.\r\nstart_date e end_date definem as datas de início e fim para a consulta, são opcionais e caso não sejam informados, todo o período será retornado, o que não é recomendado pois onera os serviços de dados do BCB que já não são lá os melhores.\r\nkeep_names é um argumento utilizado internamente que não faz diferença para o usuário final.\r\n... aqui são passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'João'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no começo que não devem ser retornadas\r\n$top define a quantidade de linhas que serão retornadas\r\n\r\nDescobrindo indicadores disponíveis\r\nPara descobrir os indicadores macroeconômicos disponíveis para um determinado endpoint é necessário realizar duas consultas. A primeira para descobrir a data mais recente com dados, pois a disponibilidade dos indicadores varia com o tempo, de maneira que temos indicadores mais recentes que não estão no histórico antigo. Tendo esta data, realizamos a segunda consulta filtrando por esta data.\r\nVamos fazer isso para cada um dos endpoints.\r\nannual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nEste endpoint tem uma coluna IndicadorDetalhe, que é como uma especificação do indicador. No caso, Balança Comercial-Saldo ou Balança Comercial-Exportações, por exemplo.\r\nmonthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nquarterly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninflation-12-months\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-annual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-monthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-selic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$select` = \"Data,indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(indicador) |>\r\n  arrange(indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nAqui temos uma pegadinha, a coluna indicador vem com sua inicial minúscula, diferente dos demais endpoints.\r\nselic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninstitutions\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2021-05-31'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConclusão\r\nObservamos que para a maior parte dos endpoints, todos exceto institutions, a última data disponível é a mesma, indicando que as estatísticas são atualizadas conjuntamente.\r\nO endpoint institutions está com última data em aproximadamente 1 ano atrás, o que me faz conjecturar que estes dados podem ser divulgados com 1 ano de atraso.\r\nUma vez que conhecemos os indicadores disponíveis podemos utilizar o argumento indic para selecionar o indicador desejado na consulta.\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        indic = c(\"IPCA\", \"IGP-M\"),\r\n                        start_date = \"2022-04-29\",\r\n                        `$select` = \"Data,Indicador,DataReferencia,Media,baseCalculo\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-05T08:09:03-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-06-03-expectativas-focus-com-rbcb/",
    "title": "Expectativas de Mercado da Pesquisa Focus no R",
    "description": "Obtendo as expectativas de mercado para os indicadores macroeconômicos da\nPesquisa Focus utilizando o R e o pacote {rbcb}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-03",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFunção get_market_expectations\r\nConhecendo os valores retornados\r\nRealizando uma consulta mais elaborada\r\nVisualizando os dados\r\nSérie temporal das expectativas de IPCA\r\nSérie temporal com intervalo informado\r\n\r\n\r\nÉ possível obter as expectativas de mercado para diversos indicadores macroeconômicos da pesquisa Focus de forma totalmente automática utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} é uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroeconômicos da pesquisa Focus são consolidadas em estatísticas diárias e divulgadas na API. Estas estatísticas são calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais instituições do mercado financeiro. Os indicadores macroeconômicos são referentes a índices de preços, crescimento do PIB e da produção industrial, taxa de câmbio, taxa Selic, variáveis fiscais e indicadores do setor externo e são publicadas todo primeiro dia útil da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFunção get_market_expectations\r\nA função get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se não for informado o valor annual será utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroeconômicos\r\ninflation-12-months para expectativas de inflação nos próximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas instituições credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroeconômico, é opcional, de forma, quando não for definido, todos os indicadores disponíveis para o endpoint serão retornados. Esse ponto é curioso, pois a documentação não é boa e informa indicadores que não são mais disponibilizados.\r\nstart_date e end_date definem as datas de início e fim para a consulta, são opcionais e caso não sejam informados, todo o período será retornado, o que não é recomendado pois onera os serviços de dados do BCB que já não são lá os melhores.\r\nkeep_names é um argumento utilizado internamente que não faz diferença para o usuário final.\r\n... aqui são passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'João'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no começo que não devem ser retornadas\r\n$top define a quantidade de linhas que serão retornadas\r\n\r\nConhecendo os valores retornados\r\nCada endpoint possui o seu conjuto de colunas retornadas e isso pode mudar com o tempo, dessa maneira, para conhecer cada API, eu recomendo fortemente que a opção $top = 10 seja utilizada para limitar uma consulta inicial para conhecimento dos valores retornados.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nComo vemos, tem muito NA. Talvez seja por que estamos visualizando dados muito antigos, vamos reordenar para trazer os dados mais recentes. Para isso é necessário definir a opção $orderby.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10,\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nJá ficou melhor, já é possível entender as informações retornadas.\r\nRealizando uma consulta mais elaborada\r\nPodemos definir melhor a consulta e o que queremos dela:\r\nretornar as colunas: Data, DataReferencia, Media, Mediana, Maximo, Minimo e DesvioPadrao. Para isso vamos utilizar a opção $select.\r\nfiltrar baseCalculo igual a 0 e DataReferencia igual a 2021 ou 2022 com a opção $filter.\r\nCom data inicial igual a 2020-12-01, para pegar os dados desde dezembro de 2020\r\n\r\n\r\ndf <- get_market_expectations(\"annual\",\r\n                              indic = \"IPCA\",\r\n                              start_date = \"2020-12-01\",\r\n                              `$filter` = \"(DataReferencia eq '2021' or DataReferencia eq '2022') and baseCalculo eq 0\",\r\n                              `$select` = \"Data,DataReferencia,Media,Mediana,DesvioPadrao,Maximo,Minimo\")\r\ndf |> head() |> rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nVisualizando os dados\r\nCom as estatísticas de expectativas de IPCA carregadas podemos começar a visualização dos dados. Estas expectativas são referentes a inflação cheia para os anos de 2021 e 2022 (DataReferencia). O filtro baseCalculo igual a 1 refere-se ao prazo de validade das expectativas informadas. Esta coluna pode ser 0 ou 1. baseCalculo igual a 0 considera as expectativas informadas nos últimos 30 dias no cálculo das estatísticas e baseCalculo igual a 1 considera os últimos 4 dias. Foi escolhida baseCalculo igual a 0 por ter uma amostra maior, consequência do período maior.\r\nSérie temporal das expectativas de IPCA\r\nVamos começar observando a série temporal das expectativas para cada DataReferencia.\r\n\r\n\r\ndf |>\r\n  ggplot(aes(x = Data, y = Mediana, group = DataReferencia, colour = DataReferencia)) +\r\n  geom_line() +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021 e 2022\",\r\n    subtitle = \"Média das expectativas de IPCA\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Inflação\"\r\n  )\r\n\r\n\r\n\r\n\r\nCurioso ver como as expectativas de inflação para 2021 mudaram ao longo de 2021, ou seja, erra-se miseravelmente. As expectativas para 2022 mudam menos, bem, isso até virar o ano.\r\nSérie temporal com intervalo informado\r\nVamos olhar agora apenas a DataReferencia 2021 e colocar as linhas de máximo e mínimo para termos uma ideia de intervalo para as expectativas.\r\n\r\n\r\ndf |>\r\n  filter(DataReferencia == 2021) |>\r\n  ggplot(aes(x = Data)) +\r\n  geom_line(aes(y = Mediana), colour = \"black\") +\r\n  geom_line(aes(y = Maximo), colour = \"grey\") +\r\n  geom_line(aes(y = Minimo), colour = \"grey\") +\r\n  geom_ribbon(aes(ymin = Minimo, ymax = Maximo), fill = \"blue\", alpha = 0.3) +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021\",\r\n    subtitle = \"Média das expectativas de IPCA com intervalo definido por máximo e mínimo da amostra\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Inflação\"\r\n  )\r\n\r\n\r\n\r\n\r\nInteressante ver como as pesquisas erram e como, mesmo os mais ousados, não saem muito do consenso. Entendo que esse é um mecanismo necessário para se colocar o “bode na sala”, entretanto, erra-se miseravelmente, são muitos vieses envolvidos.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-03-expectativas-focus-com-rbcb/expectativas-focus-com-rbcb_files/figure-html5/ipca-mediana-desviopadrao-1.png",
    "last_modified": "2022-06-05T06:59:27-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/",
    "title": "Gráficos de Composição de Índices da B3",
    "description": "Com o pacote {rb3} é possível obter a composição dos índices da B3,\ncomo o IBOVESPA, por exemplo. Vamos construir alguns gráficos donuts\npara avaliarmos a distribuição da composição dos índices.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-01",
    "categories": [
      "R",
      "rb3",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nIBOVESPA\r\nIBX 100\r\nIBX 50\r\nSMALL\r\nIFIX\r\n\r\nRecentemente, eu implementei no pacote {rb3} um conjunto de funções que baixam dados de índices do site da B3.\r\nVou mostrar aqui como utilizar a função rb3::index_weights_get, que retorna um data.frame com todas as ações que compõem um determinado índice, juntamente com os seus respectivos pesos no índice.\r\nVamos começar carregando os pacotes {rb3} e {tidyverse} que utilizo.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\n\r\n\r\nheight <- 7.5\r\nwidth <- 7.5\r\n\r\n\r\n\r\nA ideia aqui é avaliar a distribuição de ativos em alguns índices, a saber: IBOV, IBXX, IBXL, SMLL e IFIX. Contudo, essa avaliação será realizada da seguinte forma: os 10 ativos com a maior participação nos índices serão selecionados e os demais ativos serão colocado em um grupo definido como Others. Assim vou fazer um gráfico de donut (uma pizza com furo no meio) apresentando a participação de cada ativo no índice. Dessa maneira será possível avaliar a concentração dos índices.\r\nPara fazer essa seleção dos ativos e o agrupemento dos demais eu criei a função top_weight. Esta função já prepara o data.frame para a função ggdonut que constroi o gráfico de donut.\r\n\r\n\r\ntop_weight <- function(.data, n = 10) {\r\n    top_10 <- .data |>\r\n        arrange(desc(weight)) |>\r\n        slice_head(n = n) |>\r\n        select(symbol, weight)\r\n    total_weight <- sum(top_10$weight)\r\n    others <- tibble(\r\n        symbol = \"Others\",\r\n        weight = 1 - total_weight\r\n    )\r\n\r\n    bind_rows(top_10, others) |>\r\n        mutate(cum_weight = cumsum(weight)) |>\r\n        mutate(\r\n            ymax = cum_weight,\r\n            ymin = c(0, head(cum_weight, n = -1)),\r\n            label_pos = (ymax + ymin) / 2,\r\n            label = paste0(symbol, \"\\n\", scales::percent(weight)),\r\n            symbol = factor(symbol, ordered = TRUE)\r\n        )\r\n}\r\n\r\nggdonut <- function(.data, index_name) {\r\n    ggplot(.data, aes(\r\n        ymax = ymax, ymin = ymin,\r\n        xmax = 4, xmin = 3,\r\n        fill = symbol\r\n    )) +\r\n        geom_rect(colour = \"white\") +\r\n        geom_label(\r\n            x = 4.5, aes(y = label_pos, label = label), size = 3\r\n        ) +\r\n        annotate(\r\n            \"text\",\r\n            x = 0, y = 0, label = index_name, size = 16, colour = \"grey\",\r\n            fontface = 2\r\n        ) +\r\n        coord_polar(theta = \"y\") +\r\n        scale_fill_brewer(palette = \"Set3\") +\r\n        scale_color_brewer(palette = \"Set3\") +\r\n        xlim(c(0, 4)) +\r\n        theme_void() +\r\n        theme(legend.position = \"none\") +\r\n        labs(\r\n            caption = \"Source: B3 (data imported using \\U1F4E6 rb3) - wilsonfreitas\"\r\n        )\r\n}\r\n\r\n\r\n\r\nIBOVESPA\r\n\r\n\r\nindex_name <- \"IBOV\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIBX 100\r\n\r\n\r\nindex_name <- \"IBXX\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIBX 50\r\n\r\n\r\nindex_name <- \"IBXL\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nSMALL\r\n\r\n\r\nindex_name <- \"SMLL\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\nIFIX\r\n\r\n\r\nindex_name <- \"IFIX\"\r\nindex_weights_get(index_name) |>\r\n    top_weight() |>\r\n    ggdonut(index_name)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/grficos-de-composio-de-ndices-da-b3_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-06-13T11:05:26-03:00",
    "input_file": {},
    "preview_width": 1440,
    "preview_height": 1440
  },
  {
    "path": "posts/2022-01-17-dados-bcb-com-python/",
    "title": "Obtendo Dados do BCB com Python",
    "description": "Obter os dados para análise de forma simples é fundamental e necessário.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-01-17",
    "categories": [
      "Python",
      "bcb",
      "opendata"
    ],
    "contents": "\r\nObter os dados para análise de forma simples é fundamental e necessário.\r\nDepois de passar alguns anos mantendo o pacote {rbcb} que faz a integração do R com as APIs de dados abertos do Banco Central, decidi fazer o port para Python.\r\nEm parte porque o PyPI (Python Package Index - repositório de pacotes do Python) é bem menos burocrático que o CRAN (repositório de pacote do R), mas nos últimos anos tenho mexido mais com Python e fazia sentido portar algumas ferramentas.\r\nO pacote {python-bcb} é a contraparte em Python do pacote {rbcb} do R.\r\nSó que acabou ficando maior, não por causa do Python, mas por que eu estava com tempo e paciência e acabei implementando parte da especificação OData. Isso permite de forma bem simples integrar diversas APIs do Banco Central que implementam essa especificação. Na minha última contagem tinha 39 APIs nessa estrutura.\r\nO pacote {python-bcb} traz as seguintes APIs:\r\nSGS\r\nSéries de Moedas do Conversor de Moedas do Banco Central\r\nExpectativas do FOCUS\r\nBoletins da PTAX (abertura, 3 intradiários, fechamento)\r\nDados selecionados de instituições financeiras (IFDATA)\r\nAgora o que dá mais trabalho ao fazer a integração de uma API é escrever a documentação😉 dado que as APIs não são padronizadas.\r\nVou comunicando aqui na medida que novas APIs forem sendo integradas.\r\nObviamente espero todo o tipo de comentários e sugestões.\r\nDocumentação do projeto: https://wilsonfreitas.github.io/python-bcb/index.html\r\nLink do projeto: https://github.com/wilsonfreitas/python-bcb\r\nNa imagem segue um exemplo que como utilizar a API de Expectativas do FOCUS para obter um DataFrame das expectativas de IPCA de 2021 ao longo de 2021.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-01-17-dados-bcb-com-python/expectativas.png",
    "last_modified": "2022-06-03T06:11:37-03:00",
    "input_file": {},
    "preview_width": 1328,
    "preview_height": 856
  }
]
