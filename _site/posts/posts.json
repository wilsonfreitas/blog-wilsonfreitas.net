[
  {
    "path": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/",
    "title": "Histórico de Taxas de Juros em Dólar no Brasil",
    "description": "Foi analisado em um post recente a dinâmica das taxas de juros,\nbrasileira e americana.\nTrago neste post a comparação entre as taxas de juros em dólar,\nno Brasil e nos Estados Unidos.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-10",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nEm um post recente.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndusd <- yc_usd_mget(\r\n  first_date = \"2019-01-01\",\r\n  last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n  cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\n\r\n\r\nunique(dusd$refdate) |> map(function(date, df) {\r\n  df_curve <- df |>\r\n    filter(refdate == date, cur_days > 0) |>\r\n    filter(!duplicated(cur_days))\r\n  curve <- spotratecurve(\r\n    df_curve$r_360,\r\n    df_curve$cur_days,\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = date\r\n  )\r\n  interpolation(curve) <- interp_flatforward()\r\n  curve\r\n}, df = dusd) -> curves_usd\r\n\r\n\r\n\r\n\r\n\r\ncurves_usd |>\r\n  map_dfr(\\(x) tibble(\r\n    refdate = x@refdate,\r\n    r_USD_br_10y = as.numeric(x[[3600]])\r\n  )) -> rates_usd_10y\r\n\r\n\r\n\r\n\r\n\r\nrates_10y |>\r\n  left_join(rates_usd_10y, by = \"refdate\") |>\r\n  tidyr::pivot_longer(c(r_USD_br_10y, r_USD_us_10y),\r\n    names_to = \"rates\"\r\n  ) |>\r\n  ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n  geom_line() +\r\n  labs(colour = NULL) +\r\n  theme(legend.position = \"bottom\") +\r\n  labs(\r\n    x = NULL, y = NULL,\r\n    title = \"Histórico de Taxas de Juros em Dólar de 10 Anos\",\r\n    subtitle = \"Estados Unidos (r_USD_us_10y) e Brasil (r_USD_br_10y)\",\r\n    caption = \"wilsonfreitas\"\r\n  ) +\r\n  scale_y_continuous(labels = scales::percent) +\r\n  theme(legend.position = \"bottom\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-10-histrico-de-taxas-de-juros-em-dlar-no-brasil/histrico-de-taxas-de-juros-em-dlar-no-brasil_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-06-10T08:34:45-03:00",
    "input_file": "histrico-de-taxas-de-juros-em-dlar-no-brasil.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/",
    "title": "Histórico de Taxas de Juros de Longo Prazo",
    "description": "As taxas de juros de longo prazo são importantes variáveis econômicas.\nObservar a dinâmica dessas taxas é fundamental para uma boa compreensão\ndo cenário econômico.\nVamos ver como utilizar o pacote {fixedincome} para construir o histórico da\ntaxa de juros prefixada para o prazo de 10 anos com dados extraídos da B3\ncom o pacote {rb3}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-09",
    "categories": [
      "R",
      "fixedincome",
      "rb3",
      "opendata"
    ],
    "contents": "\r\nNo mercado norte americano há cotações para taxas de juros em prazos fixos, 1 ano, 5 anos, 10 anos, e assim por diante. Estas estruturas são conhecidas como Constant Term Maturities.\r\nEstes dados podem ser obtidos do site do Tesouro Americano (US Treasury) com o pacote {Quandl}.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nPodemos observar um longo histórico, desde a década de 90, para estas taxas.\r\n\r\n\r\nyc_all |>\r\n    ggplot(aes(x = Date, y = `10 YR` / 100)) +\r\n    geom_line() +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Histórico de Taxas de Juros Americanos de 10 Anos (Treasury Bonds)\",\r\n        caption = \"Dados do US Treasury obtidos com o pacote Quandl - wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent)\r\n\r\n\r\n\r\n\r\nNo mercado brasileiro, infelizmente, a vida é um pouco miserável, e não há um histórico disponível com taxas de longo prazo. É necessário construir na unha e na força do ódio.\r\nOs ativos líquidos de onde são extraídas as taxas de juros de longo prazo são os contratos futuros de taxa DI - DI1, que são cotados diariamente na B3 em seus vencimentos. Entretanto, as taxas de juros obtidas destes contratos apresentam um prazo diferente a cada dia. Assim, é necessário construir uma curva de juros com estes contratos e realizar uma interpolação nos prazos fixos, 1 ano, 5 anos, 10 anos, e por aí vai.\r\nVamos utilizar o pacote {rb3} para obter o histórico com as curvas diárias de juros prefixados do mercado brasileiro e o pacote {fixedincome} para construir os objetos de curvas de juros e realizar a interpolação das curvas nos vértices fixos para obter o histórico de taxas de juros de longo prazo.\r\nVamos começar importando os pacotes utilizados nessa jornada.\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(bizdays)\r\nlibrary(fixedincome)\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\nA função rb3::yc_mget retorna um data.frame com o histórico de curvas de juros. Vamos baixar um histórico desde 2019.\r\n\r\n\r\ndc <- yc_mget(\r\n    first_date = \"2019-01-01\",\r\n    last_date = preceding(Sys.Date() - 1, \"Brazil/ANBIMA\"),\r\n    cache_folder = \"../../../rb3-data\"\r\n)\r\n\r\n\r\n\r\nDe posse do histórico, vamos construir as curvas de juros para cada data de referência utilizando a função fixedincome::spotratecurve. A curva de juros prefixada tem as seguintes características:\r\nregime de capitalização: discrete (juros compostos)\r\nregra de contagem de dias: business/252\r\ncalendário: Brazil/ANBIMA\r\ninterpolação: flat-forward\r\nAdicionalmente faço uma limpeza nos eventuais problemas encontrados nos dados, como dias úteis zerados e duplicados. Bem, é de graça, exigir dados corretos deve ser um pouco demais, né?\r\n\r\n\r\nunique(dc$refdate) |> map(function(date, df) {\r\n    df_curve <- df |>\r\n        filter(refdate == date, biz_days > 0) |>\r\n        filter(!duplicated(biz_days))\r\n    curve <- spotratecurve(\r\n        df_curve$r_252,\r\n        df_curve$biz_days,\r\n        \"discrete\", \"business/252\", \"Brazil/ANBIMA\",\r\n        refdate = date\r\n    )\r\n    interpolation(curve) <- interp_flatforward()\r\n    curve\r\n}, df = dc) -> curves\r\n\r\n\r\n\r\nObtendo um lista com as curvas de juros utilizamos os colchetes [[ para realizar a interpolação no prazo fixo de 10 anos. Como estas curvas utilizam a regra de contagem de dias business/252, devemos considerar que 1 ano tem 252 dias úteis e portanto, 10 anos tem 2520 dias úteis. Por isso, interpolamos a curva no vértice 2520.\r\n\r\n\r\ncurves |>\r\n    map_dfr(\\(x) tibble(\r\n        refdate = x@refdate,\r\n        r_BRL_10y = as.numeric(x[[2520]])\r\n    )) -> rates_10y\r\n\r\n\r\n\r\nJá aproveito e retorno o histórico em um data.frame com as colunas refdate e r_BRL_10y. Faço isso para juntar com os dados de juros americanos de 10 anos e assim comparar a dinâmica das taxas conjuntamente.\r\n\r\n\r\nrates_10y <- rates_10y |>\r\n    left_join(yc_all |> select(Date, `10 YR`), by = c(\"refdate\" = \"Date\")) |>\r\n    rename(r_USD_us_10y = `10 YR`) |>\r\n    mutate(r_USD_us_10y = r_USD_us_10y / 100)\r\n\r\n\r\n\r\nNote que eu nomeio a taxa de juros americana com r_USD_us_10y, pois essa é uma taxa que capitaliza o dólar (USD) nos Estados Unidos (us). Abaixo faço um malabarismo com tidyr::pivot_longer para preparar os dados para o ggplot e assim visualizá-los lado a lado. Note ainda que libero a escala dos gráficos (scales = \"free_y\") para que a diferença de nível entre as taxas de juros, brasileira e americana, não afete a análise. O objetivo é visualizar a dinâmica das taxas de juros ao longo do tempo.\r\n\r\n\r\nrates_10y |>\r\n    tidyr::pivot_longer(\r\n        c(r_BRL_10y, r_USD_us_10y),\r\n        names_to = \"rates\"\r\n    ) |>\r\n    ggplot(aes(x = refdate, y = value, colour = rates)) +\r\n    geom_line() +\r\n    facet_wrap(. ~ rates, scales = \"free_y\") +\r\n    labs(\r\n        x = NULL, y = NULL,\r\n        title = \"Histórico de Taxas de Juros de 10 Anos\",\r\n        subtitle = \"Americanos (r_USD_us_10y) e Brasileiro (r_BRL_10y)\",\r\n        caption = \"wilsonfreitas\"\r\n    ) +\r\n    scale_y_continuous(labels = scales::percent) +\r\n    theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-histrico-de-taxas-de-juros-de-longo-prazo/histrico-de-taxas-de-juros-de-longo-prazo_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-06-10T08:32:28-03:00",
    "input_file": "histrico-de-taxas-de-juros-de-longo-prazo.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/",
    "title": "Curva de Juros de Americana - US Treasuries Curve",
    "description": "Como construir a curva de juros americana utilizando dados do Tesouro\nAmericano (US Treasury) e o pacote {fixedincome}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-06",
    "categories": [
      "R",
      "fixedincome",
      "opendata"
    ],
    "contents": "\r\nA curva de juros americana é uma peça fundamental do quebra-cabeças econômico/financeiro. Neste post vamos ver como obter os dados do histórico da estrutura a termo de juros dos Estados Unidos e como construir uma curva de juros utilizando o pacote {fixedincome}.\r\nVamos utilizar o Quandl, que hoje é o Nasdaq Data Link, para obter o histórico de juros americanos.\r\n\r\n\r\nlibrary(Quandl)\r\n\r\nyc_all <- Quandl(\"USTREASURY/YIELD\")\r\n\r\n\r\n\r\n\r\n\r\n\r\nyc_all traz todo o histórico de juros, as Constant Maturity Treasury rates, que relacionam as taxas de juros ao um conjuto de prazos padronizados: 1, 3, e 6 meses, e 1, 2, 3, 5, 7, 10, 20, e 30 anos.\r\n\r\n\r\nhead(yc_all)\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78 1.90  1.93  2.29\r\n2 2022-02-03 0.03 0.15 0.20 0.48 0.78 1.19 1.42 1.66 1.78  1.82  2.20\r\n3 2022-02-02 0.04 0.10 0.19 0.45 0.76 1.16 1.38 1.60 1.74  1.78  2.17\r\n4 2022-02-01 0.04 0.10 0.19 0.48 0.78 1.18 1.39 1.63 1.76  1.81  2.19\r\n5 2022-01-31 0.03 0.13 0.22 0.49 0.78 1.18 1.39 1.62 1.75  1.79  2.17\r\n6 2022-01-28 0.04 0.10 0.19 0.43 0.75 1.15 1.38 1.61 1.74  1.78  2.14\r\n  30 YR\r\n1  2.23\r\n2  2.14\r\n3  2.11\r\n4  2.12\r\n5  2.11\r\n6  2.07\r\n\r\nVamos montar a curva de juros para uma data específica utilizando os prazos definidos no histórico.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nrefdate <- as.Date(\"2022-02-04\")\r\nyc <- yc_all |> filter(Date == refdate)\r\n\r\nyc\r\n\r\n\r\n        Date 1 MO 2 MO 3 MO 6 MO 1 YR 2 YR 3 YR 5 YR 7 YR 10 YR 20 YR\r\n1 2022-02-04 0.05 0.12 0.23 0.56 0.89 1.31 1.55 1.78  1.9  1.93  2.29\r\n  30 YR\r\n1  2.23\r\n\r\nComecemos construindo o vetor de prazos da curva. Para isso precisamos interpretar os nomes das colunas e convertê-los em prazos.\r\n\r\n\r\nnx <- names(yc)\r\nterms_names <- nx[-1]\r\nterms_names\r\n\r\n\r\n [1] \"1 MO\"  \"2 MO\"  \"3 MO\"  \"6 MO\"  \"1 YR\"  \"2 YR\"  \"3 YR\"  \"5 YR\" \r\n [9] \"7 YR\"  \"10 YR\" \"20 YR\" \"30 YR\"\r\n\r\nTemos MO indicando prazos em meses e YR indicando os anos. Vamos utilizar uma simples substituição de texto para converter MO para months e YR para years. Dessa forma podemos utilizar a função fixedincome::as.term que converte um string em um objeto term (prazo).\r\n\r\n\r\nlibrary(stringr)\r\n\r\nterms_names <- terms_names |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\")\r\n\r\nterms_names\r\n\r\n\r\n [1] \"1 months\" \"2 months\" \"3 months\" \"6 months\" \"1 years\"  \"2 years\" \r\n [7] \"3 years\"  \"5 years\"  \"7 years\"  \"10 years\" \"20 years\" \"30 years\"\r\n\r\nApós a conversão usamos a função purrr::map com a função fixedincome::as.term e assim vamos obter uma lista com diversos objetos term.\r\n\r\n\r\nlibrary(purrr)\r\nlibrary(fixedincome)\r\n\r\ncurve_terms <- map(terms_names, as.term)\r\ncurve_terms\r\n\r\n\r\n[[1]]\r\n[1] \"1 month\"\r\n\r\n[[2]]\r\n[1] \"2 months\"\r\n\r\n[[3]]\r\n[1] \"3 months\"\r\n\r\n[[4]]\r\n[1] \"6 months\"\r\n\r\n[[5]]\r\n[1] \"1 year\"\r\n\r\n[[6]]\r\n[1] \"2 years\"\r\n\r\n[[7]]\r\n[1] \"3 years\"\r\n\r\n[[8]]\r\n[1] \"5 years\"\r\n\r\n[[9]]\r\n[1] \"7 years\"\r\n\r\n[[10]]\r\n[1] \"10 years\"\r\n\r\n[[11]]\r\n[1] \"20 years\"\r\n\r\n[[12]]\r\n[1] \"30 years\"\r\n\r\nObviamente tudo isso poderia ter sido feito de forma direta.\r\n\r\n\r\ncurve_terms <- nx[-1] |>\r\n  str_replace(\"MO\", \"months\") |>\r\n  str_replace(\"YR\", \"years\") |>\r\n  map(as.term)\r\n\r\n\r\n\r\nPois bem, temos uma lista com prazos em meses e prazos em anos. É necessário converter os prazos para uma mesma unidade (units). Vou converter todos os prazos para dias. Para fazer isso vou criar um objeto daycount(\"actual/360\"), que é a regra de contagem de dias que considera dias corridos e anos com 360 dias. Com a regra de contagem de dias conseguimos fazer a conversão dos prazos para anos e utilizando a quantidade de dias no ano da regra, 360, fazemos a conversão para dias.\r\n\r\n\r\ndc <- daycount(\"actual/360\")\r\n\r\nterms <- curve_terms |>\r\n    map_dbl(\\(x) dib(dc) * toyears(dc, x)) |>\r\n    term(\"days\")\r\n\r\nterms\r\n\r\n\r\n [1] \"30 days\"    \"60 days\"    \"90 days\"    \"180 days\"   \"360 days\"  \r\n [6] \"720 days\"   \"1080 days\"  \"1800 days\"  \"2520 days\"  \"3600 days\" \r\n[11] \"7200 days\"  \"10800 days\"\r\n\r\nA função fixedincome::toyears converte os prazos para um número em anos, por exemplo, 6 meses retorna 0.5, e a função dib retorna a quantidade de dias no ano para a regra, neste caso, 360. Concluímos criando os objetos de prazo com term.\r\nAgora que já temos os prazos da curva vamos extrair as taxas do data.frame. É uma operação simples de extração de linhas de um data.frame e converter em um vetor. Fazemos uma verificação de NA por que eventualmente há podemos ter valores ausentes para alguns prazos.\r\n\r\n\r\nrates <- yc[1, -1] |>\r\n    as.list() |>\r\n    as.numeric()\r\nrates <- rates / 100\r\nix <- !is.na(rates)\r\n\r\nrates[ix]\r\n\r\n\r\n [1] 0.0005 0.0012 0.0023 0.0056 0.0089 0.0131 0.0155 0.0178 0.0190\r\n[10] 0.0193 0.0229 0.0223\r\n\r\nTendo os prazos, as taxas e a data de referência, podemos construir a curva com a função fixedincome::spotratecurve. Para a curva de juros americana utilizamos taxa de juros simples (compounding simple), regra de contagem de dias (actual/360) e o calendário de dias corridos (actual).\r\n\r\n\r\ntr_curve <- spotratecurve(\r\n    rates[ix], terms[ix],\r\n    \"simple\", \"actual/360\", \"actual\",\r\n    refdate = refdate\r\n)\r\n\r\ntr_curve\r\n\r\n\r\n          SpotRateCurve\r\n30 days          0.0005\r\n60 days          0.0012\r\n90 days          0.0023\r\n180 days         0.0056\r\n360 days         0.0089\r\n720 days         0.0131\r\n1080 days        0.0155\r\n1800 days        0.0178\r\n2520 days        0.0190\r\n3600 days        0.0193\r\n# ... with 2 more rows\r\nsimple actual/360 actual \r\nReference date: 2022-02-04 \r\n\r\nNote os prazos em dias. Agora é só visualizar a curva de forma graciosa!\r\n\r\n\r\nplot(tr_curve)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-08-curva-de-juros-de-americana-us-treasuries-curve/curva-de-juros-de-americana-us-treasuries-curve_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2022-06-08T06:41:20-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-05-indicadores-da-pesquisa-focus/",
    "title": "Indicadores da Pesquisa Focus",
    "description": "As APIs de Expectativas de Mercado da Pesquisa Focus não informam\ndireito quais indicadores estão disponíveis. A documentação é meio falha e\npouco confiável. Dessa maneira, a única maneira de descobrir o que está\ndisponível é investigando a API. É isso que vou mostrar como fazer neste post.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-05",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFunção get_market_expectations\r\nDescobrindo indicadores disponíveis\r\nannual\r\nmonthly\r\nquarterly\r\ninflation-12-months\r\ntop5s-annual\r\ntop5s-monthly\r\ntop5s-selic\r\nselic\r\ninstitutions\r\n\r\nConclusão\r\n\r\nÉ possível obter as expectativas de mercado para diversos indicadores macroeconômicos da pesquisa Focus de forma totalmente automática utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} é uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroeconômicos da pesquisa Focus são consolidadas em estatísticas diárias e divulgadas na API. Estas estatísticas são calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais instituições do mercado financeiro. Os indicadores macroeconômicos são referentes a índices de preços, crescimento do PIB e da produção industrial, taxa de câmbio, taxa Selic, variáveis fiscais e indicadores do setor externo e são publicadas todo primeiro dia útil da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFunção get_market_expectations\r\nA função get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se não for informado o valor annual será utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroeconômicos\r\ninflation-12-months para expectativas de inflação nos próximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas instituições credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroeconômico, é opcional, de forma, quando não for definido, todos os indicadores disponíveis para o endpoint serão retornados. Esse ponto é curioso, pois a documentação não é boa e informa indicadores que não são mais disponibilizados.\r\nstart_date e end_date definem as datas de início e fim para a consulta, são opcionais e caso não sejam informados, todo o período será retornado, o que não é recomendado pois onera os serviços de dados do BCB que já não são lá os melhores.\r\nkeep_names é um argumento utilizado internamente que não faz diferença para o usuário final.\r\n... aqui são passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'João'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no começo que não devem ser retornadas\r\n$top define a quantidade de linhas que serão retornadas\r\n\r\nDescobrindo indicadores disponíveis\r\nPara descobrir os indicadores macroeconômicos disponíveis para um determinado endpoint é necessário realizar duas consultas. A primeira para descobrir a data mais recente com dados, pois a disponibilidade dos indicadores varia com o tempo, de maneira que temos indicadores mais recentes que não estão no histórico antigo. Tendo esta data, realizamos a segunda consulta filtrando por esta data.\r\nVamos fazer isso para cada um dos endpoints.\r\nannual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nEste endpoint tem uma coluna IndicadorDetalhe, que é como uma especificação do indicador. No caso, Balança Comercial-Saldo ou Balança Comercial-Exportações, por exemplo.\r\nmonthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nquarterly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"quarterly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninflation-12-months\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"inflation-12-months\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-annual\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-annual\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-monthly\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-monthly\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ntop5s-selic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"top5s-selic\",\r\n                        `$select` = \"Data,indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(indicador) |>\r\n  arrange(indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nAqui temos uma pegadinha, a coluna indicador vem com sua inicial minúscula, diferente dos demais endpoints.\r\nselic\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"selic\",\r\n                        `$select` = \"Data,Indicador\",\r\n                        `$filter` = \"Data eq '2022-04-29'\") |>\r\n  distinct(Indicador) |>\r\n  arrange(Indicador) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\ninstitutions\r\nConsulta 1\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$top` = 1,\r\n                        `$select` = \"Data\",\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConsulta 2\r\n\r\n\r\nget_market_expectations(\"institutions\",\r\n                        `$select` = \"Data,Indicador,IndicadorDetalhe\",\r\n                        `$filter` = \"Data eq '2021-05-31'\") |>\r\n  distinct(Indicador, IndicadorDetalhe) |>\r\n  arrange(Indicador, IndicadorDetalhe) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nConclusão\r\nObservamos que para a maior parte dos endpoints, todos exceto institutions, a última data disponível é a mesma, indicando que as estatísticas são atualizadas conjuntamente.\r\nO endpoint institutions está com última data em aproximadamente 1 ano atrás, o que me faz conjecturar que estes dados podem ser divulgados com 1 ano de atraso.\r\nUma vez que conhecemos os indicadores disponíveis podemos utilizar o argumento indic para selecionar o indicador desejado na consulta.\r\n\r\n\r\nget_market_expectations(\"monthly\",\r\n                        indic = c(\"IPCA\", \"IGP-M\"),\r\n                        start_date = \"2022-04-29\",\r\n                        `$select` = \"Data,Indicador,DataReferencia,Media,baseCalculo\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-05T08:09:03-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-06-03-expectativas-focus-com-rbcb/",
    "title": "Expectativas de Mercado da Pesquisa Focus no R",
    "description": "Obtendo as expectativas de mercado para os indicadores macroeconômicos da\nPesquisa Focus utilizando o R e o pacote {rbcb}.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-03",
    "categories": [
      "R",
      "bcb",
      "opendata"
    ],
    "contents": "\r\n\r\nContents\r\nFunção get_market_expectations\r\nConhecendo os valores retornados\r\nRealizando uma consulta mais elaborada\r\nVisualizando os dados\r\nSérie temporal das expectativas de IPCA\r\nSérie temporal com intervalo informado\r\n\r\n\r\nÉ possível obter as expectativas de mercado para diversos indicadores macroeconômicos da pesquisa Focus de forma totalmente automática utilizando o R.\r\nVamos utilizar o pacote {rbcb} para obter estes dados. O pacote {rbcb} é uma interface para algumas das diversas APIs do portal de dados abertos do Banco Central (link).\r\nAs expectativas de mercado para os indicadores macroeconômicos da pesquisa Focus são consolidadas em estatísticas diárias e divulgadas na API. Estas estatísticas são calculadas com base nas expectativas de mercado de diversos bancos, gestores de recursos e demais instituições do mercado financeiro. Os indicadores macroeconômicos são referentes a índices de preços, crescimento do PIB e da produção industrial, taxa de câmbio, taxa Selic, variáveis fiscais e indicadores do setor externo e são publicadas todo primeiro dia útil da semana.\r\nCarregando os pacotes utilizados.\r\n\r\n\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(rbcb)\r\n\r\n\r\n\r\nFunção get_market_expectations\r\nA função get_market_expectations implementa a interface para a API de expectativas de mercado da pesquisa Focus. Vejamos os seus argumentos e o que podemos fazer com eles:\r\n\r\n\r\nget_market_expectations |> args()\r\n\r\n\r\nfunction (type = c(\"annual\", \"quarterly\", \"monthly\", \"inflation-12-months\", \r\n    \"top5s-monthly\", \"top5s-annual\", \"institutions\", \"selic\", \r\n    \"top5s-selic\"), indic = NULL, start_date = NULL, end_date = NULL, \r\n    keep_names = TRUE, ...) \r\nNULL\r\n\r\ntype: A API de expectativas possui diversos endpoints e o argumento type define qual deve ser utilizado. Se não for informado o valor annual será utilizado.\r\nannual, quarterly e monthly retorna, respectivamente, as expectativas anuais, trimestrais e mensais dos indicadores macroeconômicos\r\ninflation-12-months para expectativas de inflação nos próximos 12 meses\r\ntop5s-monthly e top5s-annual retorna as expectativas mensais e anuais para os indicadores do Top 5\r\ninstitutions expectativas informadas pelas instituições credenciadas\r\nselic expectativas de mercado SELIC\r\ntop5s-selic expectativas Top 5 para SELIC\r\n\r\nindic nome do indicador macroeconômico, é opcional, de forma, quando não for definido, todos os indicadores disponíveis para o endpoint serão retornados. Esse ponto é curioso, pois a documentação não é boa e informa indicadores que não são mais disponibilizados.\r\nstart_date e end_date definem as datas de início e fim para a consulta, são opcionais e caso não sejam informados, todo o período será retornado, o que não é recomendado pois onera os serviços de dados do BCB que já não são lá os melhores.\r\nkeep_names é um argumento utilizado internamente que não faz diferença para o usuário final.\r\n... aqui são passados argumentos adicionais para a API\r\n$select define as colunas retornadas na consulta: Nome, Idade\r\n$filter define filtros mais elaborados baseado nos valores das colunas: Nome eq 'João'\r\n$orderby define como as colunas devem ser ordenadas: Nome asc, Idade desc\r\n$skip define quantidade de linhas no começo que não devem ser retornadas\r\n$top define a quantidade de linhas que serão retornadas\r\n\r\nConhecendo os valores retornados\r\nCada endpoint possui o seu conjuto de colunas retornadas e isso pode mudar com o tempo, dessa maneira, para conhecer cada API, eu recomendo fortemente que a opção $top = 10 seja utilizada para limitar uma consulta inicial para conhecimento dos valores retornados.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10) |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nComo vemos, tem muito NA. Talvez seja por que estamos visualizando dados muito antigos, vamos reordenar para trazer os dados mais recentes. Para isso é necessário definir a opção $orderby.\r\n\r\n\r\nget_market_expectations(\"annual\",\r\n                        indic = \"IPCA\",\r\n                        `$top` = 10,\r\n                        `$orderby` = \"Data desc\") |>\r\n  rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nJá ficou melhor, já é possível entender as informações retornadas.\r\nRealizando uma consulta mais elaborada\r\nPodemos definir melhor a consulta e o que queremos dela:\r\nretornar as colunas: Data, DataReferencia, Media, Mediana, Maximo, Minimo e DesvioPadrao. Para isso vamos utilizar a opção $select.\r\nfiltrar baseCalculo igual a 0 e DataReferencia igual a 2021 ou 2022 com a opção $filter.\r\nCom data inicial igual a 2020-12-01, para pegar os dados desde dezembro de 2020\r\n\r\n\r\ndf <- get_market_expectations(\"annual\",\r\n                              indic = \"IPCA\",\r\n                              start_date = \"2020-12-01\",\r\n                              `$filter` = \"(DataReferencia eq '2021' or DataReferencia eq '2022') and baseCalculo eq 0\",\r\n                              `$select` = \"Data,DataReferencia,Media,Mediana,DesvioPadrao,Maximo,Minimo\")\r\ndf |> head() |> rmarkdown::paged_table()\r\n\r\n\r\n\r\n\r\n\r\nVisualizando os dados\r\nCom as estatísticas de expectativas de IPCA carregadas podemos começar a visualização dos dados. Estas expectativas são referentes a inflação cheia para os anos de 2021 e 2022 (DataReferencia). O filtro baseCalculo igual a 1 refere-se ao prazo de validade das expectativas informadas. Esta coluna pode ser 0 ou 1. baseCalculo igual a 0 considera as expectativas informadas nos últimos 30 dias no cálculo das estatísticas e baseCalculo igual a 1 considera os últimos 4 dias. Foi escolhida baseCalculo igual a 0 por ter uma amostra maior, consequência do período maior.\r\nSérie temporal das expectativas de IPCA\r\nVamos começar observando a série temporal das expectativas para cada DataReferencia.\r\n\r\n\r\ndf |>\r\n  ggplot(aes(x = Data, y = Mediana, group = DataReferencia, colour = DataReferencia)) +\r\n  geom_line() +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021 e 2022\",\r\n    subtitle = \"Média das expectativas de IPCA\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Inflação\"\r\n  )\r\n\r\n\r\n\r\n\r\nCurioso ver como as expectativas de inflação para 2021 mudaram ao longo de 2021, ou seja, erra-se miseravelmente. As expectativas para 2022 mudam menos, bem, isso até virar o ano.\r\nSérie temporal com intervalo informado\r\nVamos olhar agora apenas a DataReferencia 2021 e colocar as linhas de máximo e mínimo para termos uma ideia de intervalo para as expectativas.\r\n\r\n\r\ndf |>\r\n  filter(DataReferencia == 2021) |>\r\n  ggplot(aes(x = Data)) +\r\n  geom_line(aes(y = Mediana), colour = \"black\") +\r\n  geom_line(aes(y = Maximo), colour = \"grey\") +\r\n  geom_line(aes(y = Minimo), colour = \"grey\") +\r\n  geom_ribbon(aes(ymin = Minimo, ymax = Maximo), fill = \"blue\", alpha = 0.3) +\r\n  labs(\r\n    title = \"Expectativas para IPCA em 2021\",\r\n    subtitle = \"Média das expectativas de IPCA com intervalo definido por máximo e mínimo da amostra\",\r\n    caption = \"Dados da Pesquisa Focus obtidos com pacote rbcb\",\r\n    x = \"Data\", y = \"Inflação\"\r\n  )\r\n\r\n\r\n\r\n\r\nInteressante ver como as pesquisas erram e como, mesmo os mais ousados, não saem muito do consenso. Entendo que esse é um mecanismo necessário para se colocar o “bode na sala”, entretanto, erra-se miseravelmente, são muitos vieses envolvidos.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-03-expectativas-focus-com-rbcb/expectativas-focus-com-rbcb_files/figure-html5/ipca-mediana-desviopadrao-1.png",
    "last_modified": "2022-06-05T06:59:27-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/",
    "title": "Gráficos de Composição de Índices da B3",
    "description": "Com o pacote {rb3} é possível obter a composição dos índices da B3, como o\nIBOVESPA, por exemplo.\nVamos construir alguns gráficos para avaliarmos características da composição\ndos índices.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-06-01",
    "categories": [
      "R",
      "rb3",
      "opendata"
    ],
    "contents": "\r\n\r\n\r\nlibrary(rb3)\r\nlibrary(tidyverse)\r\n\r\ntop_weight <- function(.data, n = 10) {\r\n    top_10 <- .data |>\r\n        arrange(desc(weight)) |>\r\n        slice_head(n = n) |>\r\n        select(symbol, weight)\r\n    total_weight <- sum(top_10$weight)\r\n    others <- tibble(\r\n        symbol = \"Others\",\r\n        weight = 1 - total_weight\r\n    )\r\n    bind_rows(top_10, others) |>\r\n        mutate(cum_weight = cumsum(weight))\r\n}\r\n\r\nindex_name <- \"IBXX\"\r\ng <- index_weights_get(index_name) |>\r\n    top_weight() |>\r\n    mutate(\r\n        ymax = cum_weight,\r\n        ymin = c(0, head(cum_weight, n = -1)),\r\n        label_pos = (ymax + ymin) / 2,\r\n        label = paste0(symbol, \"\\n\", scales::percent(weight)),\r\n        symbol = factor(symbol, ordered = TRUE)\r\n    ) |>\r\n    ggplot(aes(\r\n        ymax = ymax, ymin = ymin,\r\n        xmax = 4, xmin = 3,\r\n        fill = symbol\r\n    )) +\r\n    geom_rect(colour = \"white\") +\r\n    geom_label(\r\n        x = 4.5, aes(y = label_pos, label = label), size = 3\r\n    ) +\r\n    annotate(\r\n        \"text\",\r\n        x = 0, y = 0, label = index_name, size = 16, colour = \"grey\",\r\n        fontface = 2\r\n    ) +\r\n    coord_polar(theta = \"y\") +\r\n    scale_fill_brewer(palette = \"Set3\") +\r\n    scale_color_brewer(palette = \"Set3\") +\r\n    xlim(c(0, 4)) +\r\n    theme_void() +\r\n    theme(legend.position = \"none\") +\r\n    labs(\r\n        caption = \"Source: B3 (data imported using \\U1F4E6 rb3) - wilsonfreitas\"\r\n    )\r\n\r\ng\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-grficos-de-composio-de-ndices-da-b3/grficos-de-composio-de-ndices-da-b3_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-06-10T08:36:00-03:00",
    "input_file": "grficos-de-composio-de-ndices-da-b3.knit.md",
    "preview_width": 1344,
    "preview_height": 1344
  },
  {
    "path": "posts/2022-01-17-dados-bcb-com-python/",
    "title": "Obtendo Dados do BCB com Python",
    "description": "Obter os dados para análise de forma simples é fundamental e necessário.",
    "author": [
      {
        "name": "Wilson Freitas",
        "url": {}
      }
    ],
    "date": "2022-01-17",
    "categories": [
      "Python",
      "bcb",
      "opendata"
    ],
    "contents": "\r\nObter os dados para análise de forma simples é fundamental e necessário.\r\nDepois de passar alguns anos mantendo o pacote {rbcb} que faz a integração do R com as APIs de dados abertos do Banco Central, decidi fazer o port para Python.\r\nEm parte porque o PyPI (Python Package Index - repositório de pacotes do Python) é bem menos burocrático que o CRAN (repositório de pacote do R), mas nos últimos anos tenho mexido mais com Python e fazia sentido portar algumas ferramentas.\r\nO pacote {python-bcb} é a contraparte em Python do pacote {rbcb} do R.\r\nSó que acabou ficando maior, não por causa do Python, mas por que eu estava com tempo e paciência e acabei implementando parte da especificação OData. Isso permite de forma bem simples integrar diversas APIs do Banco Central que implementam essa especificação. Na minha última contagem tinha 39 APIs nessa estrutura.\r\nO pacote {python-bcb} traz as seguintes APIs:\r\nSGS\r\nSéries de Moedas do Conversor de Moedas do Banco Central\r\nExpectativas do FOCUS\r\nBoletins da PTAX (abertura, 3 intradiários, fechamento)\r\nDados selecionados de instituições financeiras (IFDATA)\r\nAgora o que dá mais trabalho ao fazer a integração de uma API é escrever a documentação😉 dado que as APIs não são padronizadas.\r\nVou comunicando aqui na medida que novas APIs forem sendo integradas.\r\nObviamente espero todo o tipo de comentários e sugestões.\r\nDocumentação do projeto: https://wilsonfreitas.github.io/python-bcb/index.html\r\nLink do projeto: https://github.com/wilsonfreitas/python-bcb\r\nNa imagem segue um exemplo que como utilizar a API de Expectativas do FOCUS para obter um DataFrame das expectativas de IPCA de 2021 ao longo de 2021.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-01-17-dados-bcb-com-python/expectativas.png",
    "last_modified": "2022-06-03T06:11:37-03:00",
    "input_file": {},
    "preview_width": 1328,
    "preview_height": 856
  }
]
